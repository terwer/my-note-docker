{"ast":null,"code":"require(\"core-js/modules/es.error.cause.js\");\n\n/*\n * provider.js: Abstraction providing an interface into pluggable configuration storage.\n *\n * (C) 2011, Charlie Robbins and the Contributors.\n *\n */\nvar async = require('async'),\n    common = require('./common'); //\n// ### function Provider (options)\n// #### @options {Object} Options for this instance.\n// Constructor function for the Provider object responsible\n// for exposing the pluggable storage features of `nconf`.\n//\n\n\nvar Provider = exports.Provider = function (options) {\n  //\n  // Setup default options for working with `stores`,\n  // `overrides`, `process.env` and `process.argv`.\n  //\n  options = options || {};\n  this.stores = {};\n  this.sources = [];\n  this.init(options);\n}; //\n// Define wrapper functions for using basic stores\n// in this instance\n//\n\n\n['argv', 'env'].forEach(function (type) {\n  Provider.prototype[type] = function () {\n    var args = [type].concat(Array.prototype.slice.call(arguments));\n    return this.add.apply(this, args);\n  };\n}); //\n// ### function file (key, options)\n// #### @key {string|Object} Fully qualified options, name of file store, or path.\n// #### @path {string|Object} **Optional** Full qualified options, or path.\n// Adds a new `File` store to this instance. Accepts the following options\n//\n//    nconf.file({ file: '.jitsuconf', dir: process.env.HOME, search: true });\n//    nconf.file('path/to/config/file');\n//    nconf.file('userconfig', 'path/to/config/file');\n//    nconf.file('userconfig', { file: '.jitsuconf', search: true });\n//\n\nProvider.prototype.file = function (key, options) {\n  if (arguments.length == 1) {\n    options = typeof key === 'string' ? {\n      file: key\n    } : key;\n    key = 'file';\n  } else {\n    options = typeof options === 'string' ? {\n      file: options\n    } : options;\n  }\n\n  options.type = 'file';\n  return this.add(key, options);\n}; //\n// Define wrapper functions for using\n// overrides and defaults\n//\n\n\n['defaults', 'overrides'].forEach(function (type) {\n  Provider.prototype[type] = function (options) {\n    options = options || {};\n\n    if (!options.type) {\n      options.type = 'literal';\n    }\n\n    return this.add(type, options);\n  };\n}); //\n// ### function use (name, options)\n// #### @type {string} Type of the nconf store to use.\n// #### @options {Object} Options for the store instance.\n// Adds (or replaces) a new store with the specified `name`\n// and `options`. If `options.type` is not set, then `name`\n// will be used instead:\n//\n//    provider.use('file');\n//    provider.use('file', { type: 'file', filename: '/path/to/userconf' })\n//\n\nProvider.prototype.use = function (name, options) {\n  options = options || {};\n\n  function sameOptions(store) {\n    return Object.keys(options).every(function (key) {\n      return options[key] === store[key];\n    });\n  }\n\n  var store = this.stores[name],\n      update = store && !sameOptions(store);\n\n  if (!store || update) {\n    if (update) {\n      this.remove(name);\n    }\n\n    this.add(name, options);\n  }\n\n  return this;\n}; //\n// ### function add (name, options)\n// #### @name {string} Name of the store to add to this instance\n// #### @options {Object} Options for the store to create\n// Adds a new store with the specified `name` and `options`. If `options.type`\n// is not set, then `name` will be used instead:\n//\n//    provider.add('memory');\n//    provider.add('userconf', { type: 'file', filename: '/path/to/userconf' })\n//\n\n\nProvider.prototype.add = function (name, options, usage) {\n  options = options || {};\n  var type = options.type || name;\n\n  if (!require('../nconf')[common.capitalize(type)]) {\n    throw new Error('Cannot add store with unknown type: ' + type);\n  }\n\n  this.stores[name] = this.create(type, options, usage);\n\n  if (this.stores[name].loadSync) {\n    this.stores[name].loadSync();\n  }\n\n  return this;\n}; //\n// ### function remove (name)\n// #### @name {string} Name of the store to remove from this instance\n// Removes a store with the specified `name` from this instance. Users\n// are allowed to pass in a type argument (e.g. `memory`) as name if\n// this was used in the call to `.add()`.\n//\n\n\nProvider.prototype.remove = function (name) {\n  delete this.stores[name];\n  return this;\n}; //\n// ### function create (type, options)\n// #### @type {string} Type of the nconf store to use.\n// #### @options {Object} Options for the store instance.\n// Creates a store of the specified `type` using the\n// specified `options`.\n//\n\n\nProvider.prototype.create = function (type, options, usage) {\n  return new (require('../nconf')[common.capitalize(type.toLowerCase())])(options, usage);\n}; //\n// ### function init (options)\n// #### @options {Object} Options to initialize this instance with.\n// Initializes this instance with additional `stores` or `sources` in the\n// `options` supplied.\n//\n\n\nProvider.prototype.init = function (options) {\n  var self = this; //\n  // Add any stores passed in through the options\n  // to this instance.\n  //\n\n  if (options.type) {\n    this.add(options.type, options);\n  } else if (options.store) {\n    this.add(options.store.name || options.store.type, options.store);\n  } else if (options.stores) {\n    Object.keys(options.stores).forEach(function (name) {\n      var store = options.stores[name];\n      self.add(store.name || name || store.type, store);\n    });\n  } //\n  // Add any read-only sources to this instance\n  //\n\n\n  if (options.source) {\n    this.sources.push(this.create(options.source.type || options.source.name, options.source));\n  } else if (options.sources) {\n    Object.keys(options.sources).forEach(function (name) {\n      var source = options.sources[name];\n      self.sources.push(self.create(source.type || source.name || name, source));\n    });\n  }\n}; //\n// ### function get (key, callback)\n// #### @key {string} Key to retrieve for this instance.\n// #### @callback {function} **Optional** Continuation to respond to when complete.\n// Retrieves the value for the specified key (if any).\n//\n\n\nProvider.prototype.get = function (key, callback) {\n  if (typeof key === 'function') {\n    // Allow a * key call to be made\n    callback = key;\n    key = null;\n  } //\n  // If there is no callback we can short-circuit into the default\n  // logic for traversing stores.\n  //\n\n\n  if (!callback) {\n    return this._execute('get', 1, key, callback);\n  } //\n  // Otherwise the asynchronous, hierarchical `get` is\n  // slightly more complicated because we do not need to traverse\n  // the entire set of stores, but up until there is a defined value.\n  //\n\n\n  var current = 0,\n      names = Object.keys(this.stores),\n      self = this,\n      response,\n      mergeObjs = [];\n  async.whilst(function (cb) {\n    cb(null, typeof response === 'undefined' && current < names.length);\n  }, function (next) {\n    var store = self.stores[names[current]];\n    current++;\n\n    if (store.get.length >= 2) {\n      return store.get(key, function (err, value) {\n        if (err) {\n          return next(err);\n        }\n\n        response = value; // Merge objects if necessary\n\n        if (response && typeof response === 'object' && !Array.isArray(response)) {\n          mergeObjs.push(response);\n          response = undefined;\n        }\n\n        next();\n      });\n    }\n\n    response = store.get(key); // Merge objects if necessary\n\n    if (response && typeof response === 'object' && !Array.isArray(response)) {\n      mergeObjs.push(response);\n      response = undefined;\n    }\n\n    next();\n  }, function (err) {\n    if (!err && mergeObjs.length) {\n      response = common.merge(mergeObjs.reverse());\n    }\n\n    return err ? callback(err) : callback(null, response);\n  });\n}; //\n// ### function any (keys, callback)\n// #### @keys {array|string...} Array of keys to query, or a variable list of strings\n// #### @callback {function} **Optional** Continuation to respond to when complete.\n// Retrieves the first truthy value (if any) for the specified list of keys.\n//\n\n\nProvider.prototype.any = function (keys, callback) {\n  if (!Array.isArray(keys)) {\n    keys = Array.prototype.slice.call(arguments);\n\n    if (keys.length > 0 && typeof keys[keys.length - 1] === 'function') {\n      callback = keys.pop();\n    } else {\n      callback = null;\n    }\n  } //\n  // If there is no callback, use the short-circuited \"get\"\n  // on each key in turn.\n  //\n\n\n  if (!callback) {\n    var val;\n\n    for (var i = 0; i < keys.length; ++i) {\n      val = this._execute('get', 1, keys[i], callback);\n\n      if (val) {\n        return val;\n      }\n    }\n\n    return null;\n  }\n\n  var keyIndex = 0,\n      result,\n      self = this;\n  async.whilst(function (cb) {\n    cb(null, !result && keyIndex < keys.length);\n  }, function (next) {\n    var key = keys[keyIndex];\n    keyIndex++;\n    self.get(key, function (err, v) {\n      if (err) {\n        next(err);\n      } else {\n        result = v;\n        next();\n      }\n    });\n  }, function (err) {\n    return err ? callback(err) : callback(null, result);\n  });\n}; //\n// ### function set (key, value, callback)\n// #### @key {string} Key to set in this instance\n// #### @value {literal|Object} Value for the specified key\n// #### @callback {function} **Optional** Continuation to respond to when complete.\n// Sets the `value` for the specified `key` in this instance.\n//\n\n\nProvider.prototype.set = function (key, value, callback) {\n  return this._execute('set', 2, key, value, callback);\n}; //\n// ### function required (keys)\n// #### @keys {array} List of keys\n// Throws an error if any of `keys` has no value, otherwise returns `true`\n\n\nProvider.prototype.required = function (keys) {\n  if (!Array.isArray(keys)) {\n    throw new Error('Incorrect parameter, array expected');\n  }\n\n  var missing = [];\n  keys.forEach(function (key) {\n    if (typeof this.get(key) === 'undefined') {\n      missing.push(key);\n    }\n  }, this);\n\n  if (missing.length) {\n    throw new Error('Missing required keys: ' + missing.join(', '));\n  } else {\n    return true;\n  }\n}; //\n// ### function reset (callback)\n// #### @callback {function} **Optional** Continuation to respond to when complete.\n// Clears all keys associated with this instance.\n//\n\n\nProvider.prototype.reset = function (callback) {\n  return this._execute('reset', 0, callback);\n}; //\n// ### function clear (key, callback)\n// #### @key {string} Key to remove from this instance\n// #### @callback {function} **Optional** Continuation to respond to when complete.\n// Removes the value for the specified `key` from this instance.\n//\n\n\nProvider.prototype.clear = function (key, callback) {\n  return this._execute('clear', 1, key, callback);\n}; //\n// ### function merge ([key,] value [, callback])\n// #### @key {string} Key to merge the value into\n// #### @value {literal|Object} Value to merge into the key\n// #### @callback {function} **Optional** Continuation to respond to when complete.\n// Merges the properties in `value` into the existing object value at `key`.\n//\n// 1. If the existing value `key` is not an Object, it will be completely overwritten.\n// 2. If `key` is not supplied, then the `value` will be merged into the root.\n//\n\n\nProvider.prototype.merge = function () {\n  var self = this,\n      args = Array.prototype.slice.call(arguments),\n      callback = typeof args[args.length - 1] === 'function' && args.pop(),\n      value = args.pop(),\n      key = args.pop();\n\n  function mergeProperty(prop, next) {\n    return self._execute('merge', 2, prop, value[prop], next);\n  }\n\n  if (!key) {\n    if (Array.isArray(value) || typeof value !== 'object') {\n      return onError(new Error('Cannot merge non-Object into top-level.'), callback);\n    }\n\n    return async.forEach(Object.keys(value), mergeProperty, callback || function () {});\n  }\n\n  return this._execute('merge', 2, key, value, callback);\n}; //\n// ### function load (callback)\n// #### @callback {function} Continuation to respond to when complete.\n// Responds with an Object representing all keys associated in this instance.\n//\n\n\nProvider.prototype.load = function (callback) {\n  var self = this;\n\n  function getStores() {\n    var stores = Object.keys(self.stores);\n    stores.reverse();\n    return stores.map(function (name) {\n      return self.stores[name];\n    });\n  }\n\n  function loadStoreSync(store) {\n    if (!store.loadSync) {\n      throw new Error('nconf store ' + store.type + ' has no loadSync() method');\n    }\n\n    return store.loadSync();\n  }\n\n  function loadStore(store, next) {\n    if (!store.load && !store.loadSync) {\n      return next(new Error('nconf store ' + store.type + ' has no load() method'));\n    }\n\n    return store.loadSync ? next(null, store.loadSync()) : store.load(next);\n  }\n\n  function loadBatch(targets, done) {\n    if (!done) {\n      return common.merge(targets.map(loadStoreSync));\n    }\n\n    async.map(targets, loadStore, function (err, objs) {\n      return err ? done(err) : done(null, common.merge(objs));\n    });\n  }\n\n  function mergeSources(data) {\n    //\n    // If `data` was returned then merge it into\n    // the system store.\n    //\n    if (data && typeof data === 'object') {\n      self.use('sources', {\n        type: 'literal',\n        store: data\n      });\n    }\n  }\n\n  function loadSources() {\n    var sourceHierarchy = self.sources.splice(0);\n    sourceHierarchy.reverse(); //\n    // If we don't have a callback and the current\n    // store is capable of loading synchronously\n    // then do so.\n    //\n\n    if (!callback) {\n      mergeSources(loadBatch(sourceHierarchy));\n      return loadBatch(getStores());\n    }\n\n    loadBatch(sourceHierarchy, function (err, data) {\n      if (err) {\n        return callback(err);\n      }\n\n      mergeSources(data);\n      return loadBatch(getStores(), callback);\n    });\n  }\n\n  return self.sources.length ? loadSources() : loadBatch(getStores(), callback);\n}; //\n// ### function save (callback)\n// #### @callback {function} **optional**  Continuation to respond to when\n// complete.\n// Instructs each provider to save.  If a callback is provided, we will attempt\n// asynchronous saves on the providers, falling back to synchronous saves if\n// this isn't possible.  If a provider does not know how to save, it will be\n// ignored.  Returns an object consisting of all of the data which was\n// actually saved.\n//\n\n\nProvider.prototype.save = function (value, callback) {\n  if (!callback && typeof value === 'function') {\n    callback = value;\n    value = null;\n  }\n\n  var self = this,\n      names = Object.keys(this.stores);\n\n  function saveStoreSync(memo, name) {\n    var store = self.stores[name]; //\n    // If the `store` doesn't have a `saveSync` method,\n    // just ignore it and continue.\n    //\n\n    if (store.saveSync) {\n      var ret = store.saveSync();\n\n      if (typeof ret == 'object' && ret !== null) {\n        memo.push(ret);\n      }\n    }\n\n    return memo;\n  }\n\n  function saveStore(memo, name, next) {\n    var store = self.stores[name]; //\n    // If the `store` doesn't have a `save` or saveSync`\n    // method(s), just ignore it and continue.\n    //\n\n    if (store.save) {\n      return store.save(value, function (err, data) {\n        if (err) {\n          return next(err);\n        }\n\n        if (typeof data == 'object' && data !== null) {\n          memo.push(data);\n        }\n\n        next(null, memo);\n      });\n    } else if (store.saveSync) {\n      memo.push(store.saveSync());\n    }\n\n    next(null, memo);\n  } //\n  // If we don't have a callback and the current\n  // store is capable of saving synchronously\n  // then do so.\n  //\n\n\n  if (!callback) {\n    return common.merge(names.reduce(saveStoreSync, []));\n  }\n\n  async.reduce(names, [], saveStore, function (err, objs) {\n    return err ? callback(err) : callback(null, common.merge(objs));\n  });\n}; //\n// ### @private function _execute (action, syncLength, [arguments])\n// #### @action {string} Action to execute on `this.store`.\n// #### @syncLength {number} Function length of the sync version.\n// #### @arguments {Array} Arguments array to apply to the action\n// Executes the specified `action` on all stores for this instance, ensuring a callback supplied\n// to a synchronous store function is still invoked.\n//\n\n\nProvider.prototype._execute = function (action, syncLength\n/* [arguments] */\n) {\n  var args = Array.prototype.slice.call(arguments, 2),\n      callback = typeof args[args.length - 1] === 'function' && args.pop(),\n      destructive = ['set', 'clear', 'merge', 'reset'].indexOf(action) !== -1,\n      self = this,\n      response,\n      mergeObjs = [],\n      keys = Object.keys(this.stores);\n\n  function runAction(name, next) {\n    var store = self.stores[name];\n\n    if (destructive && store.readOnly) {\n      return next();\n    }\n\n    return store[action].length > syncLength ? store[action].apply(store, args.concat(next)) : next(null, store[action].apply(store, args));\n  }\n\n  if (callback) {\n    return async.forEach(keys, runAction, function (err) {\n      return err ? callback(err) : callback();\n    });\n  }\n\n  keys.forEach(function (name) {\n    if (typeof response === 'undefined') {\n      var store = self.stores[name];\n\n      if (destructive && store.readOnly) {\n        return;\n      }\n\n      response = store[action].apply(store, args); // Merge objects if necessary\n\n      if (response && action === 'get' && typeof response === 'object' && !Array.isArray(response)) {\n        mergeObjs.push(response);\n        response = undefined;\n      }\n    }\n  });\n\n  if (mergeObjs.length) {\n    response = common.merge(mergeObjs.reverse());\n  }\n\n  return response;\n}; //\n// Throw the `err` if a callback is not supplied\n//\n\n\nfunction onError(err, callback) {\n  if (callback) {\n    return callback(err);\n  }\n\n  throw err;\n}","map":{"version":3,"names":["async","require","common","Provider","exports","options","stores","sources","init","forEach","type","prototype","args","concat","Array","slice","call","arguments","add","apply","file","key","length","use","name","sameOptions","store","Object","keys","every","update","remove","usage","capitalize","Error","create","loadSync","toLowerCase","self","source","push","get","callback","_execute","current","names","response","mergeObjs","whilst","cb","next","err","value","isArray","undefined","merge","reverse","any","pop","val","i","keyIndex","result","v","set","required","missing","join","reset","clear","mergeProperty","prop","onError","load","getStores","map","loadStoreSync","loadStore","loadBatch","targets","done","objs","mergeSources","data","loadSources","sourceHierarchy","splice","save","saveStoreSync","memo","saveSync","ret","saveStore","reduce","action","syncLength","destructive","indexOf","runAction","readOnly"],"sources":["/Users/terwer/Documents/mydocs/my-note-docker/workspace/SiYuan/data/widgets/publisher/src/publisher/node_modules/nconf/lib/nconf/provider.js"],"sourcesContent":["/*\n * provider.js: Abstraction providing an interface into pluggable configuration storage.\n *\n * (C) 2011, Charlie Robbins and the Contributors.\n *\n */\n\nvar async = require('async'),\n    common = require('./common');\n\n//\n// ### function Provider (options)\n// #### @options {Object} Options for this instance.\n// Constructor function for the Provider object responsible\n// for exposing the pluggable storage features of `nconf`.\n//\nvar Provider = exports.Provider = function (options) {\n  //\n  // Setup default options for working with `stores`,\n  // `overrides`, `process.env` and `process.argv`.\n  //\n  options       = options || {};\n  this.stores  = {};\n  this.sources = [];\n  this.init(options);\n};\n\n//\n// Define wrapper functions for using basic stores\n// in this instance\n//\n\n['argv', 'env'].forEach(function (type) {\n  Provider.prototype[type] = function () {\n    var args = [type].concat(Array.prototype.slice.call(arguments));\n    return this.add.apply(this, args);\n  };\n});\n\n//\n// ### function file (key, options)\n// #### @key {string|Object} Fully qualified options, name of file store, or path.\n// #### @path {string|Object} **Optional** Full qualified options, or path.\n// Adds a new `File` store to this instance. Accepts the following options\n//\n//    nconf.file({ file: '.jitsuconf', dir: process.env.HOME, search: true });\n//    nconf.file('path/to/config/file');\n//    nconf.file('userconfig', 'path/to/config/file');\n//    nconf.file('userconfig', { file: '.jitsuconf', search: true });\n//\nProvider.prototype.file = function (key, options) {\n  if (arguments.length == 1) {\n    options = typeof key === 'string' ? { file: key } : key;\n    key = 'file';\n  }\n  else {\n    options = typeof options === 'string'\n      ? { file: options }\n      : options;\n  }\n\n  options.type = 'file';\n  return this.add(key, options);\n};\n\n//\n// Define wrapper functions for using\n// overrides and defaults\n//\n['defaults', 'overrides'].forEach(function (type) {\n  Provider.prototype[type] = function (options) {\n    options = options || {};\n    if (!options.type) {\n      options.type = 'literal';\n    }\n\n    return this.add(type, options);\n  };\n});\n\n//\n// ### function use (name, options)\n// #### @type {string} Type of the nconf store to use.\n// #### @options {Object} Options for the store instance.\n// Adds (or replaces) a new store with the specified `name`\n// and `options`. If `options.type` is not set, then `name`\n// will be used instead:\n//\n//    provider.use('file');\n//    provider.use('file', { type: 'file', filename: '/path/to/userconf' })\n//\nProvider.prototype.use = function (name, options) {\n  options  = options      || {};\n\n  function sameOptions (store) {\n    return Object.keys(options).every(function (key) {\n      return options[key] === store[key];\n    });\n  }\n\n  var store = this.stores[name],\n      update = store && !sameOptions(store);\n\n  if (!store || update) {\n    if (update) {\n      this.remove(name);\n    }\n\n    this.add(name, options);\n  }\n\n  return this;\n};\n\n//\n// ### function add (name, options)\n// #### @name {string} Name of the store to add to this instance\n// #### @options {Object} Options for the store to create\n// Adds a new store with the specified `name` and `options`. If `options.type`\n// is not set, then `name` will be used instead:\n//\n//    provider.add('memory');\n//    provider.add('userconf', { type: 'file', filename: '/path/to/userconf' })\n//\nProvider.prototype.add = function (name, options, usage) {\n  options  = options      || {};\n  var type = options.type || name;\n\n  if (!require('../nconf')[common.capitalize(type)]) {\n    throw new Error('Cannot add store with unknown type: ' + type);\n  }\n\n  this.stores[name] = this.create(type, options, usage);\n\n  if (this.stores[name].loadSync) {\n    this.stores[name].loadSync();\n  }\n\n  return this;\n};\n\n//\n// ### function remove (name)\n// #### @name {string} Name of the store to remove from this instance\n// Removes a store with the specified `name` from this instance. Users\n// are allowed to pass in a type argument (e.g. `memory`) as name if\n// this was used in the call to `.add()`.\n//\nProvider.prototype.remove = function (name) {\n  delete this.stores[name];\n  return this;\n};\n\n//\n// ### function create (type, options)\n// #### @type {string} Type of the nconf store to use.\n// #### @options {Object} Options for the store instance.\n// Creates a store of the specified `type` using the\n// specified `options`.\n//\nProvider.prototype.create = function (type, options, usage) {\n  return new (require('../nconf')[common.capitalize(type.toLowerCase())])(options, usage);\n};\n\n//\n// ### function init (options)\n// #### @options {Object} Options to initialize this instance with.\n// Initializes this instance with additional `stores` or `sources` in the\n// `options` supplied.\n//\nProvider.prototype.init = function (options) {\n  var self = this;\n\n  //\n  // Add any stores passed in through the options\n  // to this instance.\n  //\n  if (options.type) {\n    this.add(options.type, options);\n  }\n  else if (options.store) {\n    this.add(options.store.name || options.store.type, options.store);\n  }\n  else if (options.stores) {\n    Object.keys(options.stores).forEach(function (name) {\n      var store = options.stores[name];\n      self.add(store.name || name || store.type, store);\n    });\n  }\n\n  //\n  // Add any read-only sources to this instance\n  //\n  if (options.source) {\n    this.sources.push(this.create(options.source.type || options.source.name, options.source));\n  }\n  else if (options.sources) {\n    Object.keys(options.sources).forEach(function (name) {\n      var source = options.sources[name];\n      self.sources.push(self.create(source.type || source.name || name, source));\n    });\n  }\n};\n\n//\n// ### function get (key, callback)\n// #### @key {string} Key to retrieve for this instance.\n// #### @callback {function} **Optional** Continuation to respond to when complete.\n// Retrieves the value for the specified key (if any).\n//\nProvider.prototype.get = function (key, callback) {\n  if (typeof key === 'function') {\n    // Allow a * key call to be made\n    callback = key;\n    key = null;\n  }\n\n  //\n  // If there is no callback we can short-circuit into the default\n  // logic for traversing stores.\n  //\n  if (!callback) {\n    return this._execute('get', 1, key, callback);\n  }\n\n  //\n  // Otherwise the asynchronous, hierarchical `get` is\n  // slightly more complicated because we do not need to traverse\n  // the entire set of stores, but up until there is a defined value.\n  //\n  var current = 0,\n      names = Object.keys(this.stores),\n      self = this,\n      response,\n      mergeObjs = [];\n\n  async.whilst(function (cb) {\n    cb(null, typeof response === 'undefined' && current < names.length);\n  }, function (next) {\n    var store = self.stores[names[current]];\n    current++;\n\n    if (store.get.length >= 2) {\n      return store.get(key, function (err, value) {\n        if (err) {\n          return next(err);\n        }\n\n        response = value;\n\n        // Merge objects if necessary\n        if (response && typeof response === 'object' && !Array.isArray(response)) {\n          mergeObjs.push(response);\n          response = undefined;\n        }\n\n        next();\n      });\n    }\n\n    response = store.get(key);\n\n    // Merge objects if necessary\n    if (response && typeof response === 'object' && !Array.isArray(response)) {\n      mergeObjs.push(response);\n      response = undefined;\n    }\n\n    next();\n  }, function (err) {\n    if (!err && mergeObjs.length) {\n      response = common.merge(mergeObjs.reverse());\n    }\n    return err ? callback(err) : callback(null, response);\n  });\n};\n\n\n//\n// ### function any (keys, callback)\n// #### @keys {array|string...} Array of keys to query, or a variable list of strings\n// #### @callback {function} **Optional** Continuation to respond to when complete.\n// Retrieves the first truthy value (if any) for the specified list of keys.\n//\nProvider.prototype.any = function (keys, callback) {\n\n  if (!Array.isArray(keys)) {\n    keys = Array.prototype.slice.call(arguments);\n    if (keys.length > 0 && typeof keys[keys.length - 1] === 'function') {\n      callback = keys.pop();\n    } else {\n      callback = null;\n    }\n  }\n\n  //\n  // If there is no callback, use the short-circuited \"get\"\n  // on each key in turn.\n  //\n  if (!callback) {\n    var val;\n    for (var i = 0; i < keys.length; ++i) {\n      val = this._execute('get', 1, keys[i], callback);\n      if (val) {\n        return val;\n      }\n    }\n    return null;\n  }\n\n  var keyIndex = 0,\n      result,\n      self = this;\n  \n  async.whilst(function(cb) {\n    cb(null, !result && keyIndex < keys.length);\n  }, function(next) {\n    var key = keys[keyIndex];\n    keyIndex++;\n\n    self.get(key, function(err, v) {\n      if (err) {\n        next(err);\n      } else {\n        result = v;\n        next();\n      }\n    });\n  }, function(err) {\n    return err ? callback(err) : callback(null, result);\n  });\n};\n\n\n//\n// ### function set (key, value, callback)\n// #### @key {string} Key to set in this instance\n// #### @value {literal|Object} Value for the specified key\n// #### @callback {function} **Optional** Continuation to respond to when complete.\n// Sets the `value` for the specified `key` in this instance.\n//\nProvider.prototype.set = function (key, value, callback) {\n  return this._execute('set', 2, key, value, callback);\n};\n\n\n//\n// ### function required (keys)\n// #### @keys {array} List of keys\n// Throws an error if any of `keys` has no value, otherwise returns `true`\nProvider.prototype.required = function (keys) {\n  if (!Array.isArray(keys)) {\n    throw new Error('Incorrect parameter, array expected');\n  }\n\n  var missing = [];\n  keys.forEach(function(key) {\n    if (typeof this.get(key) === 'undefined') {\n      missing.push(key);\n    }\n  }, this);\n\n  if (missing.length) {\n    throw new Error('Missing required keys: ' + missing.join(', '));\n  } else {\n    return true;\n  }\n\n};\n\n//\n// ### function reset (callback)\n// #### @callback {function} **Optional** Continuation to respond to when complete.\n// Clears all keys associated with this instance.\n//\nProvider.prototype.reset = function (callback) {\n  return this._execute('reset', 0, callback);\n};\n\n//\n// ### function clear (key, callback)\n// #### @key {string} Key to remove from this instance\n// #### @callback {function} **Optional** Continuation to respond to when complete.\n// Removes the value for the specified `key` from this instance.\n//\nProvider.prototype.clear = function (key, callback) {\n  return this._execute('clear', 1, key, callback);\n};\n\n//\n// ### function merge ([key,] value [, callback])\n// #### @key {string} Key to merge the value into\n// #### @value {literal|Object} Value to merge into the key\n// #### @callback {function} **Optional** Continuation to respond to when complete.\n// Merges the properties in `value` into the existing object value at `key`.\n//\n// 1. If the existing value `key` is not an Object, it will be completely overwritten.\n// 2. If `key` is not supplied, then the `value` will be merged into the root.\n//\nProvider.prototype.merge = function () {\n  var self = this,\n      args = Array.prototype.slice.call(arguments),\n      callback = typeof args[args.length - 1] === 'function' && args.pop(),\n      value = args.pop(),\n      key = args.pop();\n\n  function mergeProperty (prop, next) {\n    return self._execute('merge', 2, prop, value[prop], next);\n  }\n\n  if (!key) {\n    if (Array.isArray(value) || typeof value !== 'object') {\n      return onError(new Error('Cannot merge non-Object into top-level.'), callback);\n    }\n\n    return async.forEach(Object.keys(value), mergeProperty, callback || function () { })\n  }\n\n  return this._execute('merge', 2, key, value, callback);\n};\n\n//\n// ### function load (callback)\n// #### @callback {function} Continuation to respond to when complete.\n// Responds with an Object representing all keys associated in this instance.\n//\nProvider.prototype.load = function (callback) {\n  var self = this;\n\n  function getStores () {\n    var stores = Object.keys(self.stores);\n    stores.reverse();\n    return stores.map(function (name) {\n      return self.stores[name];\n    });\n  }\n\n  function loadStoreSync(store) {\n    if (!store.loadSync) {\n      throw new Error('nconf store ' + store.type + ' has no loadSync() method');\n    }\n\n    return store.loadSync();\n  }\n\n  function loadStore(store, next) {\n    if (!store.load && !store.loadSync) {\n      return next(new Error('nconf store ' + store.type + ' has no load() method'));\n    }\n\n    return store.loadSync\n      ? next(null, store.loadSync())\n      : store.load(next);\n  }\n\n  function loadBatch (targets, done) {\n    if (!done) {\n      return common.merge(targets.map(loadStoreSync));\n    }\n\n    async.map(targets, loadStore, function (err, objs) {\n      return err ? done(err) : done(null, common.merge(objs));\n    });\n  }\n\n  function mergeSources (data) {\n    //\n    // If `data` was returned then merge it into\n    // the system store.\n    //\n    if (data && typeof data === 'object') {\n      self.use('sources', {\n        type: 'literal',\n        store: data\n      });\n    }\n  }\n\n  function loadSources () {\n    var sourceHierarchy = self.sources.splice(0);\n    sourceHierarchy.reverse();\n\n    //\n    // If we don't have a callback and the current\n    // store is capable of loading synchronously\n    // then do so.\n    //\n    if (!callback) {\n      mergeSources(loadBatch(sourceHierarchy));\n      return loadBatch(getStores());\n    }\n\n    loadBatch(sourceHierarchy, function (err, data) {\n      if (err) {\n        return callback(err);\n      }\n\n      mergeSources(data);\n      return loadBatch(getStores(), callback);\n    });\n  }\n\n  return self.sources.length\n    ? loadSources()\n    : loadBatch(getStores(), callback);\n};\n\n//\n// ### function save (callback)\n// #### @callback {function} **optional**  Continuation to respond to when\n// complete.\n// Instructs each provider to save.  If a callback is provided, we will attempt\n// asynchronous saves on the providers, falling back to synchronous saves if\n// this isn't possible.  If a provider does not know how to save, it will be\n// ignored.  Returns an object consisting of all of the data which was\n// actually saved.\n//\nProvider.prototype.save = function (value, callback) {\n  if (!callback && typeof value === 'function') {\n    callback = value;\n    value = null;\n  }\n\n  var self = this,\n      names = Object.keys(this.stores);\n\n  function saveStoreSync(memo, name) {\n    var store = self.stores[name];\n\n    //\n    // If the `store` doesn't have a `saveSync` method,\n    // just ignore it and continue.\n    //\n    if (store.saveSync) {\n      var ret = store.saveSync();\n      if (typeof ret == 'object' && ret !== null) {\n        memo.push(ret);\n      }\n    }\n    return memo;\n  }\n\n  function saveStore(memo, name, next) {\n    var store = self.stores[name];\n\n    //\n    // If the `store` doesn't have a `save` or saveSync`\n    // method(s), just ignore it and continue.\n    //\n\n    if (store.save) {\n      return store.save(value, function (err, data) {\n        if (err) {\n          return next(err);\n        }\n\n        if (typeof data == 'object' && data !== null) {\n          memo.push(data);\n        }\n\n        next(null, memo);\n      });\n    }\n    else if (store.saveSync) {\n      memo.push(store.saveSync());\n    }\n\n    next(null, memo);\n  }\n\n  //\n  // If we don't have a callback and the current\n  // store is capable of saving synchronously\n  // then do so.\n  //\n  if (!callback) {\n    return common.merge(names.reduce(saveStoreSync, []));\n  }\n\n  async.reduce(names, [], saveStore, function (err, objs) {\n    return err ? callback(err) : callback(null, common.merge(objs));\n  });\n};\n\n//\n// ### @private function _execute (action, syncLength, [arguments])\n// #### @action {string} Action to execute on `this.store`.\n// #### @syncLength {number} Function length of the sync version.\n// #### @arguments {Array} Arguments array to apply to the action\n// Executes the specified `action` on all stores for this instance, ensuring a callback supplied\n// to a synchronous store function is still invoked.\n//\nProvider.prototype._execute = function (action, syncLength /* [arguments] */) {\n  var args = Array.prototype.slice.call(arguments, 2),\n      callback = typeof args[args.length - 1] === 'function' && args.pop(),\n      destructive = ['set', 'clear', 'merge', 'reset'].indexOf(action) !== -1,\n      self = this,\n      response,\n      mergeObjs = [],\n      keys = Object.keys(this.stores);\n\n\n  function runAction (name, next) {\n    var store = self.stores[name];\n\n    if (destructive && store.readOnly) {\n      return next();\n    }\n\n    return store[action].length > syncLength\n      ? store[action].apply(store, args.concat(next))\n      : next(null, store[action].apply(store, args));\n  }\n\n  if (callback) {\n    return async.forEach(keys, runAction, function (err) {\n      return err ? callback(err) : callback();\n    });\n  }\n\n  keys.forEach(function (name) {\n    if (typeof response === 'undefined') {\n      var store = self.stores[name];\n\n      if (destructive && store.readOnly) {\n        return;\n      }\n\n      response = store[action].apply(store, args);\n\n      // Merge objects if necessary\n      if (response && action === 'get' && typeof response === 'object' && !Array.isArray(response)) {\n        mergeObjs.push(response);\n        response = undefined;\n      }\n    }\n  });\n\n  if (mergeObjs.length) {\n    response = common.merge(mergeObjs.reverse());\n  }\n\n  return response;\n}\n\n//\n// Throw the `err` if a callback is not supplied\n//\nfunction onError(err, callback) {\n  if (callback) {\n    return callback(err);\n  }\n\n  throw err;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}