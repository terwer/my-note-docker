{"ast":null,"code":"'use strict';\n\nmodule.exports = writeFile;\nmodule.exports.sync = writeFileSync;\nmodule.exports._getTmpname = getTmpname; // for testing\n\nvar fs = require('graceful-fs');\n\nvar chain = require('slide').chain;\n\nvar MurmurHash3 = require('imurmurhash');\n\nvar extend = Object.assign || require('util')._extend;\n\nvar invocations = 0;\n\nfunction getTmpname(filename) {\n  return filename + '.' + MurmurHash3(__filename).hash(String(process.pid)).hash(String(++invocations)).result();\n}\n\nfunction writeFile(filename, data, options, callback) {\n  if (options instanceof Function) {\n    callback = options;\n    options = null;\n  }\n\n  if (!options) options = {};\n  fs.realpath(filename, function (_, realname) {\n    _writeFile(realname || filename, data, options, callback);\n  });\n}\n\nfunction _writeFile(filename, data, options, callback) {\n  var tmpfile = getTmpname(filename);\n\n  if (options.mode && options.chown) {\n    return thenWriteFile();\n  } else {\n    // Either mode or chown is not explicitly set\n    // Default behavior is to copy it from original file\n    return fs.stat(filename, function (err, stats) {\n      if (err || !stats) return thenWriteFile();\n      options = extend({}, options);\n\n      if (!options.mode) {\n        options.mode = stats.mode;\n      }\n\n      if (!options.chown && process.getuid) {\n        options.chown = {\n          uid: stats.uid,\n          gid: stats.gid\n        };\n      }\n\n      return thenWriteFile();\n    });\n  }\n\n  function thenWriteFile() {\n    chain([[writeFileAsync, tmpfile, data, options.mode, options.encoding || 'utf8'], options.chown && [fs, fs.chown, tmpfile, options.chown.uid, options.chown.gid], options.mode && [fs, fs.chmod, tmpfile, options.mode], [fs, fs.rename, tmpfile, filename]], function (err) {\n      err ? fs.unlink(tmpfile, function () {\n        callback(err);\n      }) : callback();\n    });\n  } // doing this instead of `fs.writeFile` in order to get the ability to\n  // call `fsync`.\n\n\n  function writeFileAsync(file, data, mode, encoding, cb) {\n    fs.open(file, 'w', options.mode, function (err, fd) {\n      if (err) return cb(err);\n\n      if (Buffer.isBuffer(data)) {\n        return fs.write(fd, data, 0, data.length, 0, syncAndClose);\n      } else if (data != null) {\n        return fs.write(fd, String(data), 0, String(encoding), syncAndClose);\n      } else {\n        return syncAndClose();\n      }\n\n      function syncAndClose(err) {\n        if (err) return cb(err);\n        fs.fsync(fd, function (err) {\n          if (err) return cb(err);\n          fs.close(fd, cb);\n        });\n      }\n    });\n  }\n}\n\nfunction writeFileSync(filename, data, options) {\n  if (!options) options = {};\n\n  try {\n    filename = fs.realpathSync(filename);\n  } catch (ex) {// it's ok, it'll happen on a not yet existing file\n  }\n\n  var tmpfile = getTmpname(filename);\n\n  try {\n    if (!options.mode || !options.chown) {\n      // Either mode or chown is not explicitly set\n      // Default behavior is to copy it from original file\n      try {\n        var stats = fs.statSync(filename);\n        options = extend({}, options);\n\n        if (!options.mode) {\n          options.mode = stats.mode;\n        }\n\n        if (!options.chown && process.getuid) {\n          options.chown = {\n            uid: stats.uid,\n            gid: stats.gid\n          };\n        }\n      } catch (ex) {// ignore stat errors\n      }\n    }\n\n    var fd = fs.openSync(tmpfile, 'w', options.mode);\n\n    if (Buffer.isBuffer(data)) {\n      fs.writeSync(fd, data, 0, data.length, 0);\n    } else if (data != null) {\n      fs.writeSync(fd, String(data), 0, String(options.encoding || 'utf8'));\n    }\n\n    fs.fsyncSync(fd);\n    fs.closeSync(fd);\n    if (options.chown) fs.chownSync(tmpfile, options.chown.uid, options.chown.gid);\n    if (options.mode) fs.chmodSync(tmpfile, options.mode);\n    fs.renameSync(tmpfile, filename);\n  } catch (err) {\n    try {\n      fs.unlinkSync(tmpfile);\n    } catch (e) {}\n\n    throw err;\n  }\n}","map":{"version":3,"names":["module","exports","writeFile","sync","writeFileSync","_getTmpname","getTmpname","fs","require","chain","MurmurHash3","extend","Object","assign","_extend","invocations","filename","__filename","hash","String","process","pid","result","data","options","callback","Function","realpath","_","realname","_writeFile","tmpfile","mode","chown","thenWriteFile","stat","err","stats","getuid","uid","gid","writeFileAsync","encoding","chmod","rename","unlink","file","cb","open","fd","Buffer","isBuffer","write","length","syncAndClose","fsync","close","realpathSync","ex","statSync","openSync","writeSync","fsyncSync","closeSync","chownSync","chmodSync","renameSync","unlinkSync","e"],"sources":["/Users/terwer/Documents/mydocs/my-note-docker/workspace/SiYuan/data/widgets/publisher/src/publisher/node_modules/write-file-atomic/index.js"],"sourcesContent":["'use strict'\nmodule.exports = writeFile\nmodule.exports.sync = writeFileSync\nmodule.exports._getTmpname = getTmpname // for testing\n\nvar fs = require('graceful-fs')\nvar chain = require('slide').chain\nvar MurmurHash3 = require('imurmurhash')\nvar extend = Object.assign || require('util')._extend\n\nvar invocations = 0\nfunction getTmpname (filename) {\n  return filename + '.' +\n    MurmurHash3(__filename)\n      .hash(String(process.pid))\n      .hash(String(++invocations))\n      .result()\n}\n\nfunction writeFile (filename, data, options, callback) {\n  if (options instanceof Function) {\n    callback = options\n    options = null\n  }\n  if (!options) options = {}\n  fs.realpath(filename, function (_, realname) {\n    _writeFile(realname || filename, data, options, callback)\n  })\n}\nfunction _writeFile (filename, data, options, callback) {\n  var tmpfile = getTmpname(filename)\n\n  if (options.mode && options.chown) {\n    return thenWriteFile()\n  } else {\n    // Either mode or chown is not explicitly set\n    // Default behavior is to copy it from original file\n    return fs.stat(filename, function (err, stats) {\n      if (err || !stats) return thenWriteFile()\n\n      options = extend({}, options)\n      if (!options.mode) {\n        options.mode = stats.mode\n      }\n      if (!options.chown && process.getuid) {\n        options.chown = { uid: stats.uid, gid: stats.gid }\n      }\n      return thenWriteFile()\n    })\n  }\n\n  function thenWriteFile () {\n    chain([\n      [writeFileAsync, tmpfile, data, options.mode, options.encoding || 'utf8'],\n      options.chown && [fs, fs.chown, tmpfile, options.chown.uid, options.chown.gid],\n      options.mode && [fs, fs.chmod, tmpfile, options.mode],\n      [fs, fs.rename, tmpfile, filename]\n    ], function (err) {\n      err ? fs.unlink(tmpfile, function () { callback(err) })\n        : callback()\n    })\n  }\n\n  // doing this instead of `fs.writeFile` in order to get the ability to\n  // call `fsync`.\n  function writeFileAsync (file, data, mode, encoding, cb) {\n    fs.open(file, 'w', options.mode, function (err, fd) {\n      if (err) return cb(err)\n      if (Buffer.isBuffer(data)) {\n        return fs.write(fd, data, 0, data.length, 0, syncAndClose)\n      } else if (data != null) {\n        return fs.write(fd, String(data), 0, String(encoding), syncAndClose)\n      } else {\n        return syncAndClose()\n      }\n      function syncAndClose (err) {\n        if (err) return cb(err)\n        fs.fsync(fd, function (err) {\n          if (err) return cb(err)\n          fs.close(fd, cb)\n        })\n      }\n    })\n  }\n}\n\nfunction writeFileSync (filename, data, options) {\n  if (!options) options = {}\n  try {\n    filename = fs.realpathSync(filename)\n  } catch (ex) {\n    // it's ok, it'll happen on a not yet existing file\n  }\n  var tmpfile = getTmpname(filename)\n\n  try {\n    if (!options.mode || !options.chown) {\n      // Either mode or chown is not explicitly set\n      // Default behavior is to copy it from original file\n      try {\n        var stats = fs.statSync(filename)\n        options = extend({}, options)\n        if (!options.mode) {\n          options.mode = stats.mode\n        }\n        if (!options.chown && process.getuid) {\n          options.chown = { uid: stats.uid, gid: stats.gid }\n        }\n      } catch (ex) {\n        // ignore stat errors\n      }\n    }\n\n    var fd = fs.openSync(tmpfile, 'w', options.mode)\n    if (Buffer.isBuffer(data)) {\n      fs.writeSync(fd, data, 0, data.length, 0)\n    } else if (data != null) {\n      fs.writeSync(fd, String(data), 0, String(options.encoding || 'utf8'))\n    }\n    fs.fsyncSync(fd)\n    fs.closeSync(fd)\n    if (options.chown) fs.chownSync(tmpfile, options.chown.uid, options.chown.gid)\n    if (options.mode) fs.chmodSync(tmpfile, options.mode)\n    fs.renameSync(tmpfile, filename)\n  } catch (err) {\n    try { fs.unlinkSync(tmpfile) } catch (e) {}\n    throw err\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}