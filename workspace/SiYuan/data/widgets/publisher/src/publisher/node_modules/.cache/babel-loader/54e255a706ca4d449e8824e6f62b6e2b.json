{"ast":null,"code":"require(\"core-js/modules/es.error.cause.js\");\n\n/*global window:false, self:false, define:false, module:false */\n\n/**\n * @license IDBWrapper - A cross-browser wrapper for IndexedDB\n * Version 1.7.2\n * Copyright (c) 2011 - 2017 Jens Arps\n * http://jensarps.de/\n *\n * Licensed under the MIT license\n */\n(function (name, definition, global) {\n  'use strict';\n\n  if (typeof define === 'function') {\n    define(definition);\n  } else if (typeof module !== 'undefined' && module.exports) {\n    module.exports = definition();\n  } else {\n    global[name] = definition();\n  }\n})('IDBStore', function () {\n  'use strict';\n\n  var defaultErrorHandler = function (error) {\n    throw error;\n  };\n\n  var defaultSuccessHandler = function () {};\n\n  var defaults = {\n    storeName: 'Store',\n    storePrefix: 'IDBWrapper-',\n    dbVersion: 1,\n    keyPath: 'id',\n    autoIncrement: true,\n    onStoreReady: function () {},\n    onError: defaultErrorHandler,\n    indexes: [],\n    implementationPreference: ['indexedDB', 'webkitIndexedDB', 'mozIndexedDB', 'shimIndexedDB']\n  };\n  /**\n   *\n   * The IDBStore constructor\n   *\n   * @constructor\n   * @name IDBStore\n   * @version 1.7.2\n   *\n   * @param {Object} [kwArgs] An options object used to configure the store and\n   *  set callbacks\n   * @param {String} [kwArgs.storeName='Store'] The name of the store\n   * @param {String} [kwArgs.storePrefix='IDBWrapper-'] A prefix that is\n   *  internally used to construct the name of the database, which will be\n   *  kwArgs.storePrefix + kwArgs.storeName\n   * @param {Number} [kwArgs.dbVersion=1] The version of the store\n   * @param {String} [kwArgs.keyPath='id'] The key path to use. If you want to\n   *  setup IDBWrapper to work with out-of-line keys, you need to set this to\n   *  `null`\n   * @param {Boolean} [kwArgs.autoIncrement=true] If set to true, IDBStore will\n   *  automatically make sure a unique keyPath value is present on each object\n   *  that is stored.\n   * @param {Function} [kwArgs.onStoreReady] A callback to be called when the\n   *  store is ready to be used.\n   * @param {Function} [kwArgs.onError=throw] A callback to be called when an\n   *  error occurred during instantiation of the store.\n   * @param {Array} [kwArgs.indexes=[]] An array of indexData objects\n   *  defining the indexes to use with the store. For every index to be used\n   *  one indexData object needs to be passed in the array.\n   *  An indexData object is defined as follows:\n   * @param {Object} [kwArgs.indexes.indexData] An object defining the index to\n   *  use\n   * @param {String} kwArgs.indexes.indexData.name The name of the index\n   * @param {String} [kwArgs.indexes.indexData.keyPath] The key path of the index\n   * @param {Boolean} [kwArgs.indexes.indexData.unique] Whether the index is unique\n   * @param {Boolean} [kwArgs.indexes.indexData.multiEntry] Whether the index is multi entry\n   * @param {Array} [kwArgs.implementationPreference=['indexedDB','webkitIndexedDB','mozIndexedDB','shimIndexedDB']] An array of strings naming implementations to be used, in order or preference\n   * @param {Function} [onStoreReady] A callback to be called when the store\n   * is ready to be used.\n   * @example\n   // create a store for customers with an additional index over the\n   // `lastname` property.\n   var myCustomerStore = new IDBStore({\n       dbVersion: 1,\n       storeName: 'customer-index',\n       keyPath: 'customerid',\n       autoIncrement: true,\n       onStoreReady: populateTable,\n       indexes: [\n           { name: 'lastname', keyPath: 'lastname', unique: false, multiEntry: false }\n       ]\n   });\n   * @example\n   // create a generic store\n   var myCustomerStore = new IDBStore({\n       storeName: 'my-data-store',\n       onStoreReady: function(){\n           // start working with the store.\n       }\n   });\n   */\n\n  var IDBStore = function (kwArgs, onStoreReady) {\n    if (typeof onStoreReady == 'undefined' && typeof kwArgs == 'function') {\n      onStoreReady = kwArgs;\n    }\n\n    if (Object.prototype.toString.call(kwArgs) != '[object Object]') {\n      kwArgs = {};\n    }\n\n    for (var key in defaults) {\n      this[key] = typeof kwArgs[key] != 'undefined' ? kwArgs[key] : defaults[key];\n    }\n\n    this.dbName = this.storePrefix + this.storeName;\n    this.dbVersion = parseInt(this.dbVersion, 10) || 1;\n    onStoreReady && (this.onStoreReady = onStoreReady);\n    var env = typeof window == 'object' ? window : self;\n    var availableImplementations = this.implementationPreference.filter(function (implName) {\n      return implName in env;\n    });\n    this.implementation = availableImplementations[0];\n    this.idb = env[this.implementation];\n    this.keyRange = env.IDBKeyRange || env.webkitIDBKeyRange || env.mozIDBKeyRange;\n    this.consts = {\n      'READ_ONLY': 'readonly',\n      'READ_WRITE': 'readwrite',\n      'VERSION_CHANGE': 'versionchange',\n      'NEXT': 'next',\n      'NEXT_NO_DUPLICATE': 'nextunique',\n      'PREV': 'prev',\n      'PREV_NO_DUPLICATE': 'prevunique'\n    };\n    this.openDB();\n  };\n  /** @lends IDBStore.prototype */\n\n\n  var proto = {\n    /**\n     * A pointer to the IDBStore ctor\n     *\n     * @private\n     * @type {Function}\n     * @constructs\n     */\n    constructor: IDBStore,\n\n    /**\n     * The version of IDBStore\n     *\n     * @type {String}\n     */\n    version: '1.7.2',\n\n    /**\n     * A reference to the IndexedDB object\n     *\n     * @type {IDBDatabase}\n     */\n    db: null,\n\n    /**\n     * The full name of the IndexedDB used by IDBStore, composed of\n     * this.storePrefix + this.storeName\n     *\n     * @type {String}\n     */\n    dbName: null,\n\n    /**\n     * The version of the IndexedDB used by IDBStore\n     *\n     * @type {Number}\n     */\n    dbVersion: null,\n\n    /**\n     * A reference to the objectStore used by IDBStore\n     *\n     * @type {IDBObjectStore}\n     */\n    store: null,\n\n    /**\n     * The store name\n     *\n     * @type {String}\n     */\n    storeName: null,\n\n    /**\n     * The prefix to prepend to the store name\n     *\n     * @type {String}\n     */\n    storePrefix: null,\n\n    /**\n     * The key path\n     *\n     * @type {String}\n     */\n    keyPath: null,\n\n    /**\n     * Whether IDBStore uses autoIncrement\n     *\n     * @type {Boolean}\n     */\n    autoIncrement: null,\n\n    /**\n     * The indexes used by IDBStore\n     *\n     * @type {Array}\n     */\n    indexes: null,\n\n    /**\n     * The implemantations to try to use, in order of preference\n     *\n     * @type {Array}\n     */\n    implementationPreference: null,\n\n    /**\n     * The actual implementation being used\n     *\n     * @type {String}\n     */\n    implementation: '',\n\n    /**\n     * The callback to be called when the store is ready to be used\n     *\n     * @type {Function}\n     */\n    onStoreReady: null,\n\n    /**\n     * The callback to be called if an error occurred during instantiation\n     * of the store\n     *\n     * @type {Function}\n     */\n    onError: null,\n\n    /**\n     * The internal insertID counter\n     *\n     * @type {Number}\n     * @private\n     */\n    _insertIdCount: 0,\n\n    /**\n     * Opens an IndexedDB; called by the constructor.\n     *\n     * Will check if versions match and compare provided index configuration\n     * with existing ones, and update indexes if necessary.\n     *\n     * Will call this.onStoreReady() if everything went well and the store\n     * is ready to use, and this.onError() is something went wrong.\n     *\n     * @private\n     *\n     */\n    openDB: function () {\n      var openRequest = this.idb.open(this.dbName, this.dbVersion);\n      var preventSuccessCallback = false;\n\n      openRequest.onerror = function (errorEvent) {\n        if (hasVersionError(errorEvent)) {\n          this.onError(new Error('The version number provided is lower than the existing one.'));\n        } else {\n          var error;\n\n          if (errorEvent.target.error) {\n            error = errorEvent.target.error;\n          } else {\n            var errorMessage = 'IndexedDB unknown error occurred when opening DB ' + this.dbName + ' version ' + this.dbVersion;\n\n            if ('errorCode' in errorEvent.target) {\n              errorMessage += ' with error code ' + errorEvent.target.errorCode;\n            }\n\n            error = new Error(errorMessage);\n          }\n\n          this.onError(error);\n        }\n      }.bind(this);\n\n      openRequest.onsuccess = function (event) {\n        if (preventSuccessCallback) {\n          return;\n        }\n\n        if (this.db) {\n          this.onStoreReady();\n          return;\n        }\n\n        this.db = event.target.result;\n\n        if (typeof this.db.version == 'string') {\n          this.onError(new Error('The IndexedDB implementation in this browser is outdated. Please upgrade your browser.'));\n          return;\n        }\n\n        if (!this.db.objectStoreNames.contains(this.storeName)) {\n          // We should never ever get here.\n          // Lets notify the user anyway.\n          this.onError(new Error('Object store couldn\\'t be created.'));\n          return;\n        }\n\n        var emptyTransaction = this.db.transaction([this.storeName], this.consts.READ_ONLY);\n        this.store = emptyTransaction.objectStore(this.storeName); // check indexes\n\n        var existingIndexes = Array.prototype.slice.call(this.getIndexList());\n        this.indexes.forEach(function (indexData) {\n          var indexName = indexData.name;\n\n          if (!indexName) {\n            preventSuccessCallback = true;\n            this.onError(new Error('Cannot create index: No index name given.'));\n            return;\n          }\n\n          this.normalizeIndexData(indexData);\n\n          if (this.hasIndex(indexName)) {\n            // check if it complies\n            var actualIndex = this.store.index(indexName);\n            var complies = this.indexComplies(actualIndex, indexData);\n\n            if (!complies) {\n              preventSuccessCallback = true;\n              this.onError(new Error('Cannot modify index \"' + indexName + '\" for current version. Please bump version number to ' + (this.dbVersion + 1) + '.'));\n            }\n\n            existingIndexes.splice(existingIndexes.indexOf(indexName), 1);\n          } else {\n            preventSuccessCallback = true;\n            this.onError(new Error('Cannot create new index \"' + indexName + '\" for current version. Please bump version number to ' + (this.dbVersion + 1) + '.'));\n          }\n        }, this);\n\n        if (existingIndexes.length) {\n          preventSuccessCallback = true;\n          this.onError(new Error('Cannot delete index(es) \"' + existingIndexes.toString() + '\" for current version. Please bump version number to ' + (this.dbVersion + 1) + '.'));\n        }\n\n        preventSuccessCallback || this.onStoreReady();\n      }.bind(this);\n\n      openRequest.onupgradeneeded = function (\n      /* IDBVersionChangeEvent */\n      event) {\n        this.db = event.target.result;\n\n        if (this.db.objectStoreNames.contains(this.storeName)) {\n          this.store = event.target.transaction.objectStore(this.storeName);\n        } else {\n          var optionalParameters = {\n            autoIncrement: this.autoIncrement\n          };\n\n          if (this.keyPath !== null) {\n            optionalParameters.keyPath = this.keyPath;\n          }\n\n          this.store = this.db.createObjectStore(this.storeName, optionalParameters);\n        }\n\n        var existingIndexes = Array.prototype.slice.call(this.getIndexList());\n        this.indexes.forEach(function (indexData) {\n          var indexName = indexData.name;\n\n          if (!indexName) {\n            preventSuccessCallback = true;\n            this.onError(new Error('Cannot create index: No index name given.'));\n          }\n\n          this.normalizeIndexData(indexData);\n\n          if (this.hasIndex(indexName)) {\n            // check if it complies\n            var actualIndex = this.store.index(indexName);\n            var complies = this.indexComplies(actualIndex, indexData);\n\n            if (!complies) {\n              // index differs, need to delete and re-create\n              this.store.deleteIndex(indexName);\n              this.store.createIndex(indexName, indexData.keyPath, {\n                unique: indexData.unique,\n                multiEntry: indexData.multiEntry\n              });\n            }\n\n            existingIndexes.splice(existingIndexes.indexOf(indexName), 1);\n          } else {\n            this.store.createIndex(indexName, indexData.keyPath, {\n              unique: indexData.unique,\n              multiEntry: indexData.multiEntry\n            });\n          }\n        }, this);\n\n        if (existingIndexes.length) {\n          existingIndexes.forEach(function (_indexName) {\n            this.store.deleteIndex(_indexName);\n          }, this);\n        }\n      }.bind(this);\n    },\n\n    /**\n     * Deletes the database used for this store if the IDB implementations\n     * provides that functionality.\n     *\n     * @param {Function} [onSuccess] A callback that is called if deletion\n     *  was successful.\n     * @param {Function} [onError] A callback that is called if deletion\n     *  failed.\n     */\n    deleteDatabase: function (onSuccess, onError) {\n      if (this.idb.deleteDatabase) {\n        this.db.close();\n        var deleteRequest = this.idb.deleteDatabase(this.dbName);\n        deleteRequest.onsuccess = onSuccess;\n        deleteRequest.onerror = onError;\n      } else {\n        onError(new Error('Browser does not support IndexedDB deleteDatabase!'));\n      }\n    },\n\n    /*********************\n     * data manipulation *\n     *********************/\n\n    /**\n     * Puts an object into the store. If an entry with the given id exists,\n     * it will be overwritten. This method has a different signature for inline\n     * keys and out-of-line keys; please see the examples below.\n     *\n     * @param {*} [key] The key to store. This is only needed if IDBWrapper\n     *  is set to use out-of-line keys. For inline keys - the default scenario -\n     *  this can be omitted.\n     * @param {Object} value The data object to store.\n     * @param {Function} [onSuccess] A callback that is called if insertion\n     *  was successful.\n     * @param {Function} [onError] A callback that is called if insertion\n     *  failed.\n     * @returns {IDBTransaction} The transaction used for this operation.\n     * @example\n     // Storing an object, using inline keys (the default scenario):\n     var myCustomer = {\n         customerid: 2346223,\n         lastname: 'Doe',\n         firstname: 'John'\n     };\n     myCustomerStore.put(myCustomer, mySuccessHandler, myErrorHandler);\n     // Note that passing success- and error-handlers is optional.\n     * @example\n     // Storing an object, using out-of-line keys:\n     var myCustomer = {\n         lastname: 'Doe',\n         firstname: 'John'\n     };\n     myCustomerStore.put(2346223, myCustomer, mySuccessHandler, myErrorHandler);\n     // Note that passing success- and error-handlers is optional.\n     */\n    put: function (key, value, onSuccess, onError) {\n      if (this.keyPath !== null) {\n        onError = onSuccess;\n        onSuccess = value;\n        value = key;\n      }\n\n      onError || (onError = defaultErrorHandler);\n      onSuccess || (onSuccess = defaultSuccessHandler);\n      var hasSuccess = false,\n          result = null,\n          putRequest;\n      var putTransaction = this.db.transaction([this.storeName], this.consts.READ_WRITE);\n\n      putTransaction.oncomplete = function () {\n        var callback = hasSuccess ? onSuccess : onError;\n        callback(result);\n      };\n\n      putTransaction.onabort = onError;\n      putTransaction.onerror = onError;\n\n      if (this.keyPath !== null) {\n        // in-line keys\n        this._addIdPropertyIfNeeded(value);\n\n        putRequest = putTransaction.objectStore(this.storeName).put(value);\n      } else {\n        // out-of-line keys\n        putRequest = putTransaction.objectStore(this.storeName).put(value, key);\n      }\n\n      putRequest.onsuccess = function (event) {\n        hasSuccess = true;\n        result = event.target.result;\n      };\n\n      putRequest.onerror = onError;\n      return putTransaction;\n    },\n\n    /**\n     * Retrieves an object from the store. If no entry exists with the given id,\n     * the success handler will be called with null as first and only argument.\n     *\n     * @param {*} key The id of the object to fetch.\n     * @param {Function} [onSuccess] A callback that is called if fetching\n     *  was successful. Will receive the object as only argument.\n     * @param {Function} [onError] A callback that will be called if an error\n     *  occurred during the operation.\n     * @returns {IDBTransaction} The transaction used for this operation.\n     */\n    get: function (key, onSuccess, onError) {\n      onError || (onError = defaultErrorHandler);\n      onSuccess || (onSuccess = defaultSuccessHandler);\n      var hasSuccess = false,\n          result = null;\n      var getTransaction = this.db.transaction([this.storeName], this.consts.READ_ONLY);\n\n      getTransaction.oncomplete = function () {\n        var callback = hasSuccess ? onSuccess : onError;\n        callback(result);\n      };\n\n      getTransaction.onabort = onError;\n      getTransaction.onerror = onError;\n      var getRequest = getTransaction.objectStore(this.storeName).get(key);\n\n      getRequest.onsuccess = function (event) {\n        hasSuccess = true;\n        result = event.target.result;\n      };\n\n      getRequest.onerror = onError;\n      return getTransaction;\n    },\n\n    /**\n     * Removes an object from the store.\n     *\n     * @param {*} key The id of the object to remove.\n     * @param {Function} [onSuccess] A callback that is called if the removal\n     *  was successful.\n     * @param {Function} [onError] A callback that will be called if an error\n     *  occurred during the operation.\n     * @returns {IDBTransaction} The transaction used for this operation.\n     */\n    remove: function (key, onSuccess, onError) {\n      onError || (onError = defaultErrorHandler);\n      onSuccess || (onSuccess = defaultSuccessHandler);\n      var hasSuccess = false,\n          result = null;\n      var removeTransaction = this.db.transaction([this.storeName], this.consts.READ_WRITE);\n\n      removeTransaction.oncomplete = function () {\n        var callback = hasSuccess ? onSuccess : onError;\n        callback(result);\n      };\n\n      removeTransaction.onabort = onError;\n      removeTransaction.onerror = onError;\n      var deleteRequest = removeTransaction.objectStore(this.storeName)['delete'](key);\n\n      deleteRequest.onsuccess = function (event) {\n        hasSuccess = true;\n        result = event.target.result;\n      };\n\n      deleteRequest.onerror = onError;\n      return removeTransaction;\n    },\n\n    /**\n     * Runs a batch of put and/or remove operations on the store.\n     *\n     * @param {Array} dataArray An array of objects containing the operation to run\n     *  and the data object (for put operations).\n     * @param {Function} [onSuccess] A callback that is called if all operations\n     *  were successful.\n     * @param {Function} [onError] A callback that is called if an error\n     *  occurred during one of the operations.\n     * @returns {IDBTransaction} The transaction used for this operation.\n     */\n    batch: function (dataArray, onSuccess, onError) {\n      onError || (onError = defaultErrorHandler);\n      onSuccess || (onSuccess = defaultSuccessHandler);\n\n      if (Object.prototype.toString.call(dataArray) != '[object Array]') {\n        onError(new Error('dataArray argument must be of type Array.'));\n      } else if (dataArray.length === 0) {\n        return onSuccess(true);\n      }\n\n      var count = dataArray.length;\n      var called = false;\n      var hasSuccess = false;\n      var batchTransaction = this.db.transaction([this.storeName], this.consts.READ_WRITE);\n\n      batchTransaction.oncomplete = function () {\n        var callback = hasSuccess ? onSuccess : onError;\n        callback(hasSuccess);\n      };\n\n      batchTransaction.onabort = onError;\n      batchTransaction.onerror = onError;\n\n      var onItemSuccess = function () {\n        count--;\n\n        if (count === 0 && !called) {\n          called = true;\n          hasSuccess = true;\n        }\n      };\n\n      dataArray.forEach(function (operation) {\n        var type = operation.type;\n        var key = operation.key;\n        var value = operation.value;\n\n        var onItemError = function (err) {\n          batchTransaction.abort();\n\n          if (!called) {\n            called = true;\n            onError(err, type, key);\n          }\n        };\n\n        if (type == 'remove') {\n          var deleteRequest = batchTransaction.objectStore(this.storeName)['delete'](key);\n          deleteRequest.onsuccess = onItemSuccess;\n          deleteRequest.onerror = onItemError;\n        } else if (type == 'put') {\n          var putRequest;\n\n          if (this.keyPath !== null) {\n            // in-line keys\n            this._addIdPropertyIfNeeded(value);\n\n            putRequest = batchTransaction.objectStore(this.storeName).put(value);\n          } else {\n            // out-of-line keys\n            putRequest = batchTransaction.objectStore(this.storeName).put(value, key);\n          }\n\n          putRequest.onsuccess = onItemSuccess;\n          putRequest.onerror = onItemError;\n        }\n      }, this);\n      return batchTransaction;\n    },\n\n    /**\n     * Takes an array of objects and stores them in a single transaction.\n     *\n     * @param {Array} dataArray An array of objects to store\n     * @param {Function} [onSuccess] A callback that is called if all operations\n     *  were successful.\n     * @param {Function} [onError] A callback that is called if an error\n     *  occurred during one of the operations.\n     * @returns {IDBTransaction} The transaction used for this operation.\n     */\n    putBatch: function (dataArray, onSuccess, onError) {\n      var batchData = dataArray.map(function (item) {\n        return {\n          type: 'put',\n          value: item\n        };\n      });\n      return this.batch(batchData, onSuccess, onError);\n    },\n\n    /**\n     * Like putBatch, takes an array of objects and stores them in a single\n     * transaction, but allows processing of the result values.  Returns the\n     * processed records containing the key for newly created records to the\n     * onSuccess calllback instead of only returning true or false for success.\n     * In addition, added the option for the caller to specify a key field that\n     * should be set to the newly created key.\n     *\n     * @param {Array} dataArray An array of objects to store\n     * @param {Object} [options] An object containing optional options\n     * @param {String} [options.keyField=this.keyPath] Specifies a field in the record to update\n     *  with the auto-incrementing key. Defaults to the store's keyPath.\n     * @param {Function} [onSuccess] A callback that is called if all operations\n     *  were successful.\n     * @param {Function} [onError] A callback that is called if an error\n     *  occurred during one of the operations.\n     * @returns {IDBTransaction} The transaction used for this operation.\n     *\n     */\n    upsertBatch: function (dataArray, options, onSuccess, onError) {\n      // handle `dataArray, onSuccess, onError` signature\n      if (typeof options == 'function') {\n        onSuccess = options;\n        onError = onSuccess;\n        options = {};\n      }\n\n      onError || (onError = defaultErrorHandler);\n      onSuccess || (onSuccess = defaultSuccessHandler);\n      options || (options = {});\n\n      if (Object.prototype.toString.call(dataArray) != '[object Array]') {\n        onError(new Error('dataArray argument must be of type Array.'));\n      }\n\n      var keyField = options.keyField || this.keyPath;\n      var count = dataArray.length;\n      var called = false;\n      var hasSuccess = false;\n      var index = 0; // assume success callbacks are executed in order\n\n      var batchTransaction = this.db.transaction([this.storeName], this.consts.READ_WRITE);\n\n      batchTransaction.oncomplete = function () {\n        if (hasSuccess) {\n          onSuccess(dataArray);\n        } else {\n          onError(false);\n        }\n      };\n\n      batchTransaction.onabort = onError;\n      batchTransaction.onerror = onError;\n\n      var onItemSuccess = function (event) {\n        var record = dataArray[index++];\n        record[keyField] = event.target.result;\n        count--;\n\n        if (count === 0 && !called) {\n          called = true;\n          hasSuccess = true;\n        }\n      };\n\n      dataArray.forEach(function (record) {\n        var key = record.key;\n\n        var onItemError = function (err) {\n          batchTransaction.abort();\n\n          if (!called) {\n            called = true;\n            onError(err);\n          }\n        };\n\n        var putRequest;\n\n        if (this.keyPath !== null) {\n          // in-line keys\n          this._addIdPropertyIfNeeded(record);\n\n          putRequest = batchTransaction.objectStore(this.storeName).put(record);\n        } else {\n          // out-of-line keys\n          putRequest = batchTransaction.objectStore(this.storeName).put(record, key);\n        }\n\n        putRequest.onsuccess = onItemSuccess;\n        putRequest.onerror = onItemError;\n      }, this);\n      return batchTransaction;\n    },\n\n    /**\n     * Takes an array of keys and removes matching objects in a single\n     * transaction.\n     *\n     * @param {Array} keyArray An array of keys to remove\n     * @param {Function} [onSuccess] A callback that is called if all operations\n     *  were successful.\n     * @param {Function} [onError] A callback that is called if an error\n     *  occurred during one of the operations.\n     * @returns {IDBTransaction} The transaction used for this operation.\n     */\n    removeBatch: function (keyArray, onSuccess, onError) {\n      var batchData = keyArray.map(function (key) {\n        return {\n          type: 'remove',\n          key: key\n        };\n      });\n      return this.batch(batchData, onSuccess, onError);\n    },\n\n    /**\n     * Takes an array of keys and fetches matching objects\n     *\n     * @param {Array} keyArray An array of keys identifying the objects to fetch\n     * @param {Function} [onSuccess] A callback that is called if all operations\n     *  were successful.\n     * @param {Function} [onError] A callback that is called if an error\n     *  occurred during one of the operations.\n     * @param {String} [arrayType='sparse'] The type of array to pass to the\n     *  success handler. May be one of 'sparse', 'dense' or 'skip'. Defaults to\n     *  'sparse'. This parameter specifies how to handle the situation if a get\n     *  operation did not throw an error, but there was no matching object in\n     *  the database. In most cases, 'sparse' provides the most desired\n     *  behavior. See the examples for details.\n     * @returns {IDBTransaction} The transaction used for this operation.\n     * @example\n     // given that there are two objects in the database with the keypath\n     // values 1 and 2, and the call looks like this:\n     myStore.getBatch([1, 5, 2], onError, function (data) { â€¦ }, arrayType);\n      // this is what the `data` array will be like:\n      // arrayType == 'sparse':\n     // data is a sparse array containing two entries and having a length of 3:\n     [Object, 2: Object]\n     0: Object\n     2: Object\n     length: 3\n     // calling forEach on data will result in the callback being called two\n     // times, with the index parameter matching the index of the key in the\n     // keyArray.\n      // arrayType == 'dense':\n     // data is a dense array containing three entries and having a length of 3,\n     // where data[1] is of type undefined:\n     [Object, undefined, Object]\n     0: Object\n     1: undefined\n     2: Object\n     length: 3\n     // calling forEach on data will result in the callback being called three\n     // times, with the index parameter matching the index of the key in the\n     // keyArray, but the second call will have undefined as first argument.\n      // arrayType == 'skip':\n     // data is a dense array containing two entries and having a length of 2:\n     [Object, Object]\n     0: Object\n     1: Object\n     length: 2\n     // calling forEach on data will result in the callback being called two\n     // times, with the index parameter not matching the index of the key in the\n     // keyArray.\n     */\n    getBatch: function (keyArray, onSuccess, onError, arrayType) {\n      onError || (onError = defaultErrorHandler);\n      onSuccess || (onSuccess = defaultSuccessHandler);\n      arrayType || (arrayType = 'sparse');\n\n      if (Object.prototype.toString.call(keyArray) != '[object Array]') {\n        onError(new Error('keyArray argument must be of type Array.'));\n      } else if (keyArray.length === 0) {\n        return onSuccess([]);\n      }\n\n      var data = [];\n      var count = keyArray.length;\n      var called = false;\n      var hasSuccess = false;\n      var result = null;\n      var batchTransaction = this.db.transaction([this.storeName], this.consts.READ_ONLY);\n\n      batchTransaction.oncomplete = function () {\n        var callback = hasSuccess ? onSuccess : onError;\n        callback(result);\n      };\n\n      batchTransaction.onabort = onError;\n      batchTransaction.onerror = onError;\n\n      var onItemSuccess = function (event) {\n        if (event.target.result || arrayType == 'dense') {\n          data.push(event.target.result);\n        } else if (arrayType == 'sparse') {\n          data.length++;\n        }\n\n        count--;\n\n        if (count === 0) {\n          called = true;\n          hasSuccess = true;\n          result = data;\n        }\n      };\n\n      keyArray.forEach(function (key) {\n        var onItemError = function (err) {\n          called = true;\n          result = err;\n          onError(err);\n          batchTransaction.abort();\n        };\n\n        var getRequest = batchTransaction.objectStore(this.storeName).get(key);\n        getRequest.onsuccess = onItemSuccess;\n        getRequest.onerror = onItemError;\n      }, this);\n      return batchTransaction;\n    },\n\n    /**\n     * Fetches all entries in the store.\n     *\n     * @param {Function} [onSuccess] A callback that is called if the operation\n     *  was successful. Will receive an array of objects.\n     * @param {Function} [onError] A callback that will be called if an error\n     *  occurred during the operation.\n     * @returns {IDBTransaction} The transaction used for this operation.\n     */\n    getAll: function (onSuccess, onError) {\n      onError || (onError = defaultErrorHandler);\n      onSuccess || (onSuccess = defaultSuccessHandler);\n      var getAllTransaction = this.db.transaction([this.storeName], this.consts.READ_ONLY);\n      var store = getAllTransaction.objectStore(this.storeName);\n\n      if (store.getAll) {\n        this._getAllNative(getAllTransaction, store, onSuccess, onError);\n      } else {\n        this._getAllCursor(getAllTransaction, store, onSuccess, onError);\n      }\n\n      return getAllTransaction;\n    },\n\n    /**\n     * Implements getAll for IDB implementations that have a non-standard\n     * getAll() method.\n     *\n     * @param {IDBTransaction} getAllTransaction An open READ transaction.\n     * @param {IDBObjectStore} store A reference to the store.\n     * @param {Function} onSuccess A callback that will be called if the\n     *  operation was successful.\n     * @param {Function} onError A callback that will be called if an\n     *  error occurred during the operation.\n     * @private\n     */\n    _getAllNative: function (getAllTransaction, store, onSuccess, onError) {\n      var hasSuccess = false,\n          result = null;\n\n      getAllTransaction.oncomplete = function () {\n        var callback = hasSuccess ? onSuccess : onError;\n        callback(result);\n      };\n\n      getAllTransaction.onabort = onError;\n      getAllTransaction.onerror = onError;\n      var getAllRequest = store.getAll();\n\n      getAllRequest.onsuccess = function (event) {\n        hasSuccess = true;\n        result = event.target.result;\n      };\n\n      getAllRequest.onerror = onError;\n    },\n\n    /**\n     * Implements getAll for IDB implementations that do not have a getAll()\n     * method.\n     *\n     * @param {IDBTransaction} getAllTransaction An open READ transaction.\n     * @param {IDBObjectStore} store A reference to the store.\n     * @param {Function} onSuccess A callback that will be called if the\n     *  operation was successful.\n     * @param {Function} onError A callback that will be called if an\n     *  error occurred during the operation.\n     * @private\n     */\n    _getAllCursor: function (getAllTransaction, store, onSuccess, onError) {\n      var all = [],\n          hasSuccess = false,\n          result = null;\n\n      getAllTransaction.oncomplete = function () {\n        var callback = hasSuccess ? onSuccess : onError;\n        callback(result);\n      };\n\n      getAllTransaction.onabort = onError;\n      getAllTransaction.onerror = onError;\n      var cursorRequest = store.openCursor();\n\n      cursorRequest.onsuccess = function (event) {\n        var cursor = event.target.result;\n\n        if (cursor) {\n          all.push(cursor.value);\n          cursor['continue']();\n        } else {\n          hasSuccess = true;\n          result = all;\n        }\n      };\n\n      cursorRequest.onError = onError;\n    },\n\n    /**\n     * Clears the store, i.e. deletes all entries in the store.\n     *\n     * @param {Function} [onSuccess] A callback that will be called if the\n     *  operation was successful.\n     * @param {Function} [onError] A callback that will be called if an\n     *  error occurred during the operation.\n     * @returns {IDBTransaction} The transaction used for this operation.\n     */\n    clear: function (onSuccess, onError) {\n      onError || (onError = defaultErrorHandler);\n      onSuccess || (onSuccess = defaultSuccessHandler);\n      var hasSuccess = false,\n          result = null;\n      var clearTransaction = this.db.transaction([this.storeName], this.consts.READ_WRITE);\n\n      clearTransaction.oncomplete = function () {\n        var callback = hasSuccess ? onSuccess : onError;\n        callback(result);\n      };\n\n      clearTransaction.onabort = onError;\n      clearTransaction.onerror = onError;\n      var clearRequest = clearTransaction.objectStore(this.storeName).clear();\n\n      clearRequest.onsuccess = function (event) {\n        hasSuccess = true;\n        result = event.target.result;\n      };\n\n      clearRequest.onerror = onError;\n      return clearTransaction;\n    },\n\n    /**\n     * Checks if an id property needs to present on a object and adds one if\n     * necessary.\n     *\n     * @param {Object} dataObj The data object that is about to be stored\n     * @private\n     */\n    _addIdPropertyIfNeeded: function (dataObj) {\n      if (typeof dataObj[this.keyPath] == 'undefined') {\n        dataObj[this.keyPath] = this._insertIdCount++ + Date.now();\n      }\n    },\n\n    /************\n     * indexing *\n     ************/\n\n    /**\n     * Returns a DOMStringList of index names of the store.\n     *\n     * @return {DOMStringList} The list of index names\n     */\n    getIndexList: function () {\n      return this.store.indexNames;\n    },\n\n    /**\n     * Checks if an index with the given name exists in the store.\n     *\n     * @param {String} indexName The name of the index to look for\n     * @return {Boolean} Whether the store contains an index with the given name\n     */\n    hasIndex: function (indexName) {\n      return this.store.indexNames.contains(indexName);\n    },\n\n    /**\n     * Normalizes an object containing index data and assures that all\n     * properties are set.\n     *\n     * @param {Object} indexData The index data object to normalize\n     * @param {String} indexData.name The name of the index\n     * @param {String} [indexData.keyPath] The key path of the index\n     * @param {Boolean} [indexData.unique] Whether the index is unique\n     * @param {Boolean} [indexData.multiEntry] Whether the index is multi entry\n     */\n    normalizeIndexData: function (indexData) {\n      indexData.keyPath = indexData.keyPath || indexData.name;\n      indexData.unique = !!indexData.unique;\n      indexData.multiEntry = !!indexData.multiEntry;\n    },\n\n    /**\n     * Checks if an actual index complies with an expected index.\n     *\n     * @param {IDBIndex} actual The actual index found in the store\n     * @param {Object} expected An Object describing an expected index\n     * @return {Boolean} Whether both index definitions are identical\n     */\n    indexComplies: function (actual, expected) {\n      var complies = ['keyPath', 'unique', 'multiEntry'].every(function (key) {\n        // IE10 returns undefined for no multiEntry\n        if (key == 'multiEntry' && actual[key] === undefined && expected[key] === false) {\n          return true;\n        } // Compound keys\n\n\n        if (key == 'keyPath' && Object.prototype.toString.call(expected[key]) == '[object Array]') {\n          var exp = expected.keyPath;\n          var act = actual.keyPath; // IE10 can't handle keyPath sequences and stores them as a string.\n          // The index will be unusable there, but let's still return true if\n          // the keyPath sequence matches.\n\n          if (typeof act == 'string') {\n            return exp.toString() == act;\n          } // Chrome/Opera stores keyPath squences as DOMStringList, Firefox\n          // as Array\n\n\n          if (!(typeof act.contains == 'function' || typeof act.indexOf == 'function')) {\n            return false;\n          }\n\n          if (act.length !== exp.length) {\n            return false;\n          }\n\n          for (var i = 0, m = exp.length; i < m; i++) {\n            if (!(act.contains && act.contains(exp[i]) || act.indexOf(exp[i] !== -1))) {\n              return false;\n            }\n          }\n\n          return true;\n        }\n\n        return expected[key] == actual[key];\n      });\n      return complies;\n    },\n\n    /**********\n     * cursor *\n     **********/\n\n    /**\n     * Iterates over the store using the given options and calling onItem\n     * for each entry matching the options.\n     *\n     * @param {Function} onItem A callback to be called for each match\n     * @param {Object} [options] An object defining specific options\n     * @param {String} [options.index=null] A name of an IDBIndex to operate on\n     * @param {String} [options.order=ASC] The order in which to provide the\n     *  results, can be 'DESC' or 'ASC'\n     * @param {Boolean} [options.autoContinue=true] Whether to automatically\n     *  iterate the cursor to the next result\n     * @param {Boolean} [options.filterDuplicates=false] Whether to exclude\n     *  duplicate matches\n     * @param {IDBKeyRange} [options.keyRange=null] An IDBKeyRange to use\n     * @param {Boolean} [options.writeAccess=false] Whether grant write access\n     *  to the store in the onItem callback\n     * @param {Function} [options.onEnd=null] A callback to be called after\n     *  iteration has ended\n     * @param {Function} [options.onError=throw] A callback to be called\n     *  if an error occurred during the operation.\n     * @param {Number} [options.limit=Infinity] Limit the number of returned\n     *  results to this number\n     * @param {Number} [options.offset=0] Skip the provided number of results\n     *  in the resultset\n     * @param {Boolean} [options.allowItemRejection=false] Allows the onItem\n     * function to return a Boolean to accept or reject the current item\n     * @returns {IDBTransaction} The transaction used for this operation.\n     */\n    iterate: function (onItem, options) {\n      options = mixin({\n        index: null,\n        order: 'ASC',\n        autoContinue: true,\n        filterDuplicates: false,\n        keyRange: null,\n        writeAccess: false,\n        onEnd: null,\n        onError: defaultErrorHandler,\n        limit: Infinity,\n        offset: 0,\n        allowItemRejection: false\n      }, options || {});\n      var directionType = options.order.toLowerCase() == 'desc' ? 'PREV' : 'NEXT';\n\n      if (options.filterDuplicates) {\n        directionType += '_NO_DUPLICATE';\n      }\n\n      var hasSuccess = false;\n      var cursorTransaction = this.db.transaction([this.storeName], this.consts[options.writeAccess ? 'READ_WRITE' : 'READ_ONLY']);\n      var cursorTarget = cursorTransaction.objectStore(this.storeName);\n\n      if (options.index) {\n        cursorTarget = cursorTarget.index(options.index);\n      }\n\n      var recordCount = 0;\n\n      cursorTransaction.oncomplete = function () {\n        if (!hasSuccess) {\n          options.onError(null);\n          return;\n        }\n\n        if (options.onEnd) {\n          options.onEnd();\n        } else {\n          onItem(null);\n        }\n      };\n\n      cursorTransaction.onabort = options.onError;\n      cursorTransaction.onerror = options.onError;\n      var cursorRequest = cursorTarget.openCursor(options.keyRange, this.consts[directionType]);\n      cursorRequest.onerror = options.onError;\n\n      cursorRequest.onsuccess = function (event) {\n        var cursor = event.target.result;\n\n        if (cursor) {\n          if (options.offset) {\n            cursor.advance(options.offset);\n            options.offset = 0;\n          } else {\n            var onItemReturn = onItem(cursor.value, cursor, cursorTransaction);\n\n            if (!options.allowItemRejection || onItemReturn !== false) {\n              recordCount++;\n            }\n\n            if (options.autoContinue) {\n              if (recordCount + options.offset < options.limit) {\n                cursor['continue']();\n              } else {\n                hasSuccess = true;\n              }\n            }\n          }\n        } else {\n          hasSuccess = true;\n        }\n      };\n\n      return cursorTransaction;\n    },\n\n    /**\n     * Runs a query against the store and passes an array containing matched\n     * objects to the success handler.\n     *\n     * @param {Function} onSuccess A callback to be called when the operation\n     *  was successful.\n     * @param {Object} [options] An object defining specific options\n     * @param {String} [options.index=null] A name of an IDBIndex to operate on\n     * @param {String} [options.order=ASC] The order in which to provide the\n     *  results, can be 'DESC' or 'ASC'\n     * @param {Boolean} [options.filterDuplicates=false] Whether to exclude\n     *  duplicate matches\n     * @param {IDBKeyRange} [options.keyRange=null] An IDBKeyRange to use\n     * @param {Function} [options.onError=throw] A callback to be called\n     *  if an error occurred during the operation.\n     * @param {Number} [options.limit=Infinity] Limit the number of returned\n     *  results to this number\n     * @param {Number} [options.offset=0] Skip the provided number of results\n     *  in the resultset\n     * @param {Function} [options.filter=null] A custom filter function to\n     *  apply to query resuts before returning. Must return `false` to reject\n     *  an item. Can be combined with keyRanges.\n     * @returns {IDBTransaction} The transaction used for this operation.\n     */\n    query: function (onSuccess, options) {\n      var result = [],\n          processedItems = 0;\n      options = options || {};\n      options.autoContinue = true;\n      options.writeAccess = false;\n      options.allowItemRejection = !!options.filter;\n\n      options.onEnd = function () {\n        onSuccess(result, processedItems);\n      };\n\n      return this.iterate(function (item) {\n        processedItems++;\n        var accept = options.filter ? options.filter(item) : true;\n\n        if (accept !== false) {\n          result.push(item);\n        }\n\n        return accept;\n      }, options);\n    },\n\n    /**\n     *\n     * Runs a query against the store, but only returns the number of matches\n     * instead of the matches itself.\n     *\n     * @param {Function} onSuccess A callback to be called if the opration\n     *  was successful.\n     * @param {Object} [options] An object defining specific options\n     * @param {String} [options.index=null] A name of an IDBIndex to operate on\n     * @param {IDBKeyRange} [options.keyRange=null] An IDBKeyRange to use\n     * @param {Function} [options.onError=throw] A callback to be called if an error\n     *  occurred during the operation.\n     * @returns {IDBTransaction} The transaction used for this operation.\n     */\n    count: function (onSuccess, options) {\n      options = mixin({\n        index: null,\n        keyRange: null\n      }, options || {});\n      var onError = options.onError || defaultErrorHandler;\n      var hasSuccess = false,\n          result = null;\n      var cursorTransaction = this.db.transaction([this.storeName], this.consts.READ_ONLY);\n\n      cursorTransaction.oncomplete = function () {\n        var callback = hasSuccess ? onSuccess : onError;\n        callback(result);\n      };\n\n      cursorTransaction.onabort = onError;\n      cursorTransaction.onerror = onError;\n      var cursorTarget = cursorTransaction.objectStore(this.storeName);\n\n      if (options.index) {\n        cursorTarget = cursorTarget.index(options.index);\n      }\n\n      var countRequest = cursorTarget.count(options.keyRange);\n\n      countRequest.onsuccess = function (evt) {\n        hasSuccess = true;\n        result = evt.target.result;\n      };\n\n      countRequest.onError = onError;\n      return cursorTransaction;\n    },\n\n    /**************/\n\n    /* key ranges */\n\n    /**************/\n\n    /**\n     * Creates a key range using specified options. This key range can be\n     * handed over to the count() and iterate() methods.\n     *\n     * Note: You must provide at least one or both of \"lower\" or \"upper\" value.\n     *\n     * @param {Object} options The options for the key range to create\n     * @param {*} [options.lower] The lower bound\n     * @param {Boolean} [options.excludeLower] Whether to exclude the lower\n     *  bound passed in options.lower from the key range\n     * @param {*} [options.upper] The upper bound\n     * @param {Boolean} [options.excludeUpper] Whether to exclude the upper\n     *  bound passed in options.upper from the key range\n     * @param {*} [options.only] A single key value. Use this if you need a key\n     *  range that only includes one value for a key. Providing this\n     *  property invalidates all other properties.\n     * @return {IDBKeyRange} The IDBKeyRange representing the specified options\n     */\n    makeKeyRange: function (options) {\n      /*jshint onecase:true */\n      var keyRange,\n          hasLower = typeof options.lower != 'undefined',\n          hasUpper = typeof options.upper != 'undefined',\n          isOnly = typeof options.only != 'undefined';\n\n      switch (true) {\n        case isOnly:\n          keyRange = this.keyRange.only(options.only);\n          break;\n\n        case hasLower && hasUpper:\n          keyRange = this.keyRange.bound(options.lower, options.upper, options.excludeLower, options.excludeUpper);\n          break;\n\n        case hasLower:\n          keyRange = this.keyRange.lowerBound(options.lower, options.excludeLower);\n          break;\n\n        case hasUpper:\n          keyRange = this.keyRange.upperBound(options.upper, options.excludeUpper);\n          break;\n\n        default:\n          throw new Error('Cannot create KeyRange. Provide one or both of \"lower\" or \"upper\" value, or an \"only\" value.');\n      }\n\n      return keyRange;\n    }\n  };\n  /** helpers **/\n\n  var empty = {};\n\n  function mixin(target, source) {\n    var name, s;\n\n    for (name in source) {\n      s = source[name];\n\n      if (s !== empty[name] && s !== target[name]) {\n        target[name] = s;\n      }\n    }\n\n    return target;\n  }\n\n  function hasVersionError(errorEvent) {\n    if ('error' in errorEvent.target) {\n      return errorEvent.target.error.name == 'VersionError';\n    } else if ('errorCode' in errorEvent.target) {\n      return errorEvent.target.errorCode == 12;\n    }\n\n    return false;\n  }\n\n  IDBStore.prototype = proto;\n  IDBStore.version = proto.version;\n  return IDBStore;\n}, this);","map":{"version":3,"names":["name","definition","global","define","module","exports","defaultErrorHandler","error","defaultSuccessHandler","defaults","storeName","storePrefix","dbVersion","keyPath","autoIncrement","onStoreReady","onError","indexes","implementationPreference","IDBStore","kwArgs","Object","prototype","toString","call","key","dbName","parseInt","env","window","self","availableImplementations","filter","implName","implementation","idb","keyRange","IDBKeyRange","webkitIDBKeyRange","mozIDBKeyRange","consts","openDB","proto","constructor","version","db","store","_insertIdCount","openRequest","open","preventSuccessCallback","onerror","errorEvent","hasVersionError","Error","target","errorMessage","errorCode","bind","onsuccess","event","result","objectStoreNames","contains","emptyTransaction","transaction","READ_ONLY","objectStore","existingIndexes","Array","slice","getIndexList","forEach","indexData","indexName","normalizeIndexData","hasIndex","actualIndex","index","complies","indexComplies","splice","indexOf","length","onupgradeneeded","optionalParameters","createObjectStore","deleteIndex","createIndex","unique","multiEntry","_indexName","deleteDatabase","onSuccess","close","deleteRequest","put","value","hasSuccess","putRequest","putTransaction","READ_WRITE","oncomplete","callback","onabort","_addIdPropertyIfNeeded","get","getTransaction","getRequest","remove","removeTransaction","batch","dataArray","count","called","batchTransaction","onItemSuccess","operation","type","onItemError","err","abort","putBatch","batchData","map","item","upsertBatch","options","keyField","record","removeBatch","keyArray","getBatch","arrayType","data","push","getAll","getAllTransaction","_getAllNative","_getAllCursor","getAllRequest","all","cursorRequest","openCursor","cursor","clear","clearTransaction","clearRequest","dataObj","Date","now","indexNames","actual","expected","every","undefined","exp","act","i","m","iterate","onItem","mixin","order","autoContinue","filterDuplicates","writeAccess","onEnd","limit","Infinity","offset","allowItemRejection","directionType","toLowerCase","cursorTransaction","cursorTarget","recordCount","advance","onItemReturn","query","processedItems","accept","countRequest","evt","makeKeyRange","hasLower","lower","hasUpper","upper","isOnly","only","bound","excludeLower","excludeUpper","lowerBound","upperBound","empty","source","s"],"sources":["/Users/terwer/Documents/mydocs/my-note-docker/workspace/SiYuan/data/widgets/publisher/src/publisher/node_modules/idb-wrapper/idbstore.js"],"sourcesContent":["/*global window:false, self:false, define:false, module:false */\n\n/**\n * @license IDBWrapper - A cross-browser wrapper for IndexedDB\n * Version 1.7.2\n * Copyright (c) 2011 - 2017 Jens Arps\n * http://jensarps.de/\n *\n * Licensed under the MIT license\n */\n\n(function (name, definition, global) {\n\n    'use strict';\n\n    if (typeof define === 'function') {\n        define(definition);\n    } else if (typeof module !== 'undefined' && module.exports) {\n        module.exports = definition();\n    } else {\n        global[name] = definition();\n    }\n})('IDBStore', function () {\n\n    'use strict';\n\n    var defaultErrorHandler = function (error) {\n        throw error;\n    };\n    var defaultSuccessHandler = function () {\n    };\n\n    var defaults = {\n        storeName: 'Store',\n        storePrefix: 'IDBWrapper-',\n        dbVersion: 1,\n        keyPath: 'id',\n        autoIncrement: true,\n        onStoreReady: function () {\n        },\n        onError: defaultErrorHandler,\n        indexes: [],\n        implementationPreference: [\n            'indexedDB',\n            'webkitIndexedDB',\n            'mozIndexedDB',\n            'shimIndexedDB'\n        ]\n    };\n\n    /**\n     *\n     * The IDBStore constructor\n     *\n     * @constructor\n     * @name IDBStore\n     * @version 1.7.2\n     *\n     * @param {Object} [kwArgs] An options object used to configure the store and\n     *  set callbacks\n     * @param {String} [kwArgs.storeName='Store'] The name of the store\n     * @param {String} [kwArgs.storePrefix='IDBWrapper-'] A prefix that is\n     *  internally used to construct the name of the database, which will be\n     *  kwArgs.storePrefix + kwArgs.storeName\n     * @param {Number} [kwArgs.dbVersion=1] The version of the store\n     * @param {String} [kwArgs.keyPath='id'] The key path to use. If you want to\n     *  setup IDBWrapper to work with out-of-line keys, you need to set this to\n     *  `null`\n     * @param {Boolean} [kwArgs.autoIncrement=true] If set to true, IDBStore will\n     *  automatically make sure a unique keyPath value is present on each object\n     *  that is stored.\n     * @param {Function} [kwArgs.onStoreReady] A callback to be called when the\n     *  store is ready to be used.\n     * @param {Function} [kwArgs.onError=throw] A callback to be called when an\n     *  error occurred during instantiation of the store.\n     * @param {Array} [kwArgs.indexes=[]] An array of indexData objects\n     *  defining the indexes to use with the store. For every index to be used\n     *  one indexData object needs to be passed in the array.\n     *  An indexData object is defined as follows:\n     * @param {Object} [kwArgs.indexes.indexData] An object defining the index to\n     *  use\n     * @param {String} kwArgs.indexes.indexData.name The name of the index\n     * @param {String} [kwArgs.indexes.indexData.keyPath] The key path of the index\n     * @param {Boolean} [kwArgs.indexes.indexData.unique] Whether the index is unique\n     * @param {Boolean} [kwArgs.indexes.indexData.multiEntry] Whether the index is multi entry\n     * @param {Array} [kwArgs.implementationPreference=['indexedDB','webkitIndexedDB','mozIndexedDB','shimIndexedDB']] An array of strings naming implementations to be used, in order or preference\n     * @param {Function} [onStoreReady] A callback to be called when the store\n     * is ready to be used.\n     * @example\n     // create a store for customers with an additional index over the\n     // `lastname` property.\n     var myCustomerStore = new IDBStore({\n         dbVersion: 1,\n         storeName: 'customer-index',\n         keyPath: 'customerid',\n         autoIncrement: true,\n         onStoreReady: populateTable,\n         indexes: [\n             { name: 'lastname', keyPath: 'lastname', unique: false, multiEntry: false }\n         ]\n     });\n     * @example\n     // create a generic store\n     var myCustomerStore = new IDBStore({\n         storeName: 'my-data-store',\n         onStoreReady: function(){\n             // start working with the store.\n         }\n     });\n     */\n    var IDBStore = function (kwArgs, onStoreReady) {\n\n        if (typeof onStoreReady == 'undefined' && typeof kwArgs == 'function') {\n            onStoreReady = kwArgs;\n        }\n        if (Object.prototype.toString.call(kwArgs) != '[object Object]') {\n            kwArgs = {};\n        }\n\n        for (var key in defaults) {\n            this[key] = typeof kwArgs[key] != 'undefined' ? kwArgs[key] : defaults[key];\n        }\n\n        this.dbName = this.storePrefix + this.storeName;\n        this.dbVersion = parseInt(this.dbVersion, 10) || 1;\n\n        onStoreReady && (this.onStoreReady = onStoreReady);\n\n        var env = typeof window == 'object' ? window : self;\n        var availableImplementations = this.implementationPreference.filter(function (implName) {\n            return implName in env;\n        });\n        this.implementation = availableImplementations[0];\n        this.idb = env[this.implementation];\n        this.keyRange = env.IDBKeyRange || env.webkitIDBKeyRange || env.mozIDBKeyRange;\n\n        this.consts = {\n            'READ_ONLY': 'readonly',\n            'READ_WRITE': 'readwrite',\n            'VERSION_CHANGE': 'versionchange',\n            'NEXT': 'next',\n            'NEXT_NO_DUPLICATE': 'nextunique',\n            'PREV': 'prev',\n            'PREV_NO_DUPLICATE': 'prevunique'\n        };\n\n        this.openDB();\n    };\n\n    /** @lends IDBStore.prototype */\n    var proto = {\n\n        /**\n         * A pointer to the IDBStore ctor\n         *\n         * @private\n         * @type {Function}\n         * @constructs\n         */\n        constructor: IDBStore,\n\n        /**\n         * The version of IDBStore\n         *\n         * @type {String}\n         */\n        version: '1.7.2',\n\n        /**\n         * A reference to the IndexedDB object\n         *\n         * @type {IDBDatabase}\n         */\n        db: null,\n\n        /**\n         * The full name of the IndexedDB used by IDBStore, composed of\n         * this.storePrefix + this.storeName\n         *\n         * @type {String}\n         */\n        dbName: null,\n\n        /**\n         * The version of the IndexedDB used by IDBStore\n         *\n         * @type {Number}\n         */\n        dbVersion: null,\n\n        /**\n         * A reference to the objectStore used by IDBStore\n         *\n         * @type {IDBObjectStore}\n         */\n        store: null,\n\n        /**\n         * The store name\n         *\n         * @type {String}\n         */\n        storeName: null,\n\n        /**\n         * The prefix to prepend to the store name\n         *\n         * @type {String}\n         */\n        storePrefix: null,\n\n        /**\n         * The key path\n         *\n         * @type {String}\n         */\n        keyPath: null,\n\n        /**\n         * Whether IDBStore uses autoIncrement\n         *\n         * @type {Boolean}\n         */\n        autoIncrement: null,\n\n        /**\n         * The indexes used by IDBStore\n         *\n         * @type {Array}\n         */\n        indexes: null,\n\n        /**\n         * The implemantations to try to use, in order of preference\n         *\n         * @type {Array}\n         */\n        implementationPreference: null,\n\n        /**\n         * The actual implementation being used\n         *\n         * @type {String}\n         */\n        implementation: '',\n\n        /**\n         * The callback to be called when the store is ready to be used\n         *\n         * @type {Function}\n         */\n        onStoreReady: null,\n\n        /**\n         * The callback to be called if an error occurred during instantiation\n         * of the store\n         *\n         * @type {Function}\n         */\n        onError: null,\n\n        /**\n         * The internal insertID counter\n         *\n         * @type {Number}\n         * @private\n         */\n        _insertIdCount: 0,\n\n        /**\n         * Opens an IndexedDB; called by the constructor.\n         *\n         * Will check if versions match and compare provided index configuration\n         * with existing ones, and update indexes if necessary.\n         *\n         * Will call this.onStoreReady() if everything went well and the store\n         * is ready to use, and this.onError() is something went wrong.\n         *\n         * @private\n         *\n         */\n        openDB: function () {\n\n            var openRequest = this.idb.open(this.dbName, this.dbVersion);\n            var preventSuccessCallback = false;\n\n            openRequest.onerror = function (errorEvent) {\n\n                if (hasVersionError(errorEvent)) {\n                    this.onError(new Error('The version number provided is lower than the existing one.'));\n                } else {\n                    var error;\n\n                    if (errorEvent.target.error) {\n                        error = errorEvent.target.error;\n                    } else {\n                        var errorMessage = 'IndexedDB unknown error occurred when opening DB ' + this.dbName + ' version ' + this.dbVersion;\n                        if ('errorCode' in errorEvent.target) {\n                            errorMessage += ' with error code ' + errorEvent.target.errorCode;\n                        }\n                        error = new Error(errorMessage);\n                    }\n\n                    this.onError(error);\n                }\n            }.bind(this);\n\n            openRequest.onsuccess = function (event) {\n\n                if (preventSuccessCallback) {\n                    return;\n                }\n\n                if (this.db) {\n                    this.onStoreReady();\n                    return;\n                }\n\n                this.db = event.target.result;\n\n                if (typeof this.db.version == 'string') {\n                    this.onError(new Error('The IndexedDB implementation in this browser is outdated. Please upgrade your browser.'));\n                    return;\n                }\n\n                if (!this.db.objectStoreNames.contains(this.storeName)) {\n                    // We should never ever get here.\n                    // Lets notify the user anyway.\n                    this.onError(new Error('Object store couldn\\'t be created.'));\n                    return;\n                }\n\n                var emptyTransaction = this.db.transaction([this.storeName], this.consts.READ_ONLY);\n                this.store = emptyTransaction.objectStore(this.storeName);\n\n                // check indexes\n                var existingIndexes = Array.prototype.slice.call(this.getIndexList());\n                this.indexes.forEach(function (indexData) {\n                    var indexName = indexData.name;\n\n                    if (!indexName) {\n                        preventSuccessCallback = true;\n                        this.onError(new Error('Cannot create index: No index name given.'));\n                        return;\n                    }\n\n                    this.normalizeIndexData(indexData);\n\n                    if (this.hasIndex(indexName)) {\n                        // check if it complies\n                        var actualIndex = this.store.index(indexName);\n                        var complies = this.indexComplies(actualIndex, indexData);\n                        if (!complies) {\n                            preventSuccessCallback = true;\n                            this.onError(new Error('Cannot modify index \"' + indexName + '\" for current version. Please bump version number to ' + ( this.dbVersion + 1 ) + '.'));\n                        }\n\n                        existingIndexes.splice(existingIndexes.indexOf(indexName), 1);\n                    } else {\n                        preventSuccessCallback = true;\n                        this.onError(new Error('Cannot create new index \"' + indexName + '\" for current version. Please bump version number to ' + ( this.dbVersion + 1 ) + '.'));\n                    }\n\n                }, this);\n\n                if (existingIndexes.length) {\n                    preventSuccessCallback = true;\n                    this.onError(new Error('Cannot delete index(es) \"' + existingIndexes.toString() + '\" for current version. Please bump version number to ' + ( this.dbVersion + 1 ) + '.'));\n                }\n\n                preventSuccessCallback || this.onStoreReady();\n            }.bind(this);\n\n            openRequest.onupgradeneeded = function (/* IDBVersionChangeEvent */ event) {\n\n                this.db = event.target.result;\n\n                if (this.db.objectStoreNames.contains(this.storeName)) {\n                    this.store = event.target.transaction.objectStore(this.storeName);\n                } else {\n                    var optionalParameters = {autoIncrement: this.autoIncrement};\n                    if (this.keyPath !== null) {\n                        optionalParameters.keyPath = this.keyPath;\n                    }\n                    this.store = this.db.createObjectStore(this.storeName, optionalParameters);\n                }\n\n                var existingIndexes = Array.prototype.slice.call(this.getIndexList());\n                this.indexes.forEach(function (indexData) {\n                    var indexName = indexData.name;\n\n                    if (!indexName) {\n                        preventSuccessCallback = true;\n                        this.onError(new Error('Cannot create index: No index name given.'));\n                    }\n\n                    this.normalizeIndexData(indexData);\n\n                    if (this.hasIndex(indexName)) {\n                        // check if it complies\n                        var actualIndex = this.store.index(indexName);\n                        var complies = this.indexComplies(actualIndex, indexData);\n                        if (!complies) {\n                            // index differs, need to delete and re-create\n                            this.store.deleteIndex(indexName);\n                            this.store.createIndex(indexName, indexData.keyPath, {\n                                unique: indexData.unique,\n                                multiEntry: indexData.multiEntry\n                            });\n                        }\n\n                        existingIndexes.splice(existingIndexes.indexOf(indexName), 1);\n                    } else {\n                        this.store.createIndex(indexName, indexData.keyPath, {\n                            unique: indexData.unique,\n                            multiEntry: indexData.multiEntry\n                        });\n                    }\n\n                }, this);\n\n                if (existingIndexes.length) {\n                    existingIndexes.forEach(function (_indexName) {\n                        this.store.deleteIndex(_indexName);\n                    }, this);\n                }\n\n            }.bind(this);\n        },\n\n        /**\n         * Deletes the database used for this store if the IDB implementations\n         * provides that functionality.\n         *\n         * @param {Function} [onSuccess] A callback that is called if deletion\n         *  was successful.\n         * @param {Function} [onError] A callback that is called if deletion\n         *  failed.\n         */\n        deleteDatabase: function (onSuccess, onError) {\n            if (this.idb.deleteDatabase) {\n                this.db.close();\n                var deleteRequest = this.idb.deleteDatabase(this.dbName);\n                deleteRequest.onsuccess = onSuccess;\n                deleteRequest.onerror = onError;\n            } else {\n                onError(new Error('Browser does not support IndexedDB deleteDatabase!'));\n            }\n        },\n\n        /*********************\n         * data manipulation *\n         *********************/\n\n        /**\n         * Puts an object into the store. If an entry with the given id exists,\n         * it will be overwritten. This method has a different signature for inline\n         * keys and out-of-line keys; please see the examples below.\n         *\n         * @param {*} [key] The key to store. This is only needed if IDBWrapper\n         *  is set to use out-of-line keys. For inline keys - the default scenario -\n         *  this can be omitted.\n         * @param {Object} value The data object to store.\n         * @param {Function} [onSuccess] A callback that is called if insertion\n         *  was successful.\n         * @param {Function} [onError] A callback that is called if insertion\n         *  failed.\n         * @returns {IDBTransaction} The transaction used for this operation.\n         * @example\n         // Storing an object, using inline keys (the default scenario):\n         var myCustomer = {\n             customerid: 2346223,\n             lastname: 'Doe',\n             firstname: 'John'\n         };\n         myCustomerStore.put(myCustomer, mySuccessHandler, myErrorHandler);\n         // Note that passing success- and error-handlers is optional.\n         * @example\n         // Storing an object, using out-of-line keys:\n         var myCustomer = {\n             lastname: 'Doe',\n             firstname: 'John'\n         };\n         myCustomerStore.put(2346223, myCustomer, mySuccessHandler, myErrorHandler);\n         // Note that passing success- and error-handlers is optional.\n         */\n        put: function (key, value, onSuccess, onError) {\n            if (this.keyPath !== null) {\n                onError = onSuccess;\n                onSuccess = value;\n                value = key;\n            }\n            onError || (onError = defaultErrorHandler);\n            onSuccess || (onSuccess = defaultSuccessHandler);\n\n            var hasSuccess = false,\n                result = null,\n                putRequest;\n\n            var putTransaction = this.db.transaction([this.storeName], this.consts.READ_WRITE);\n            putTransaction.oncomplete = function () {\n                var callback = hasSuccess ? onSuccess : onError;\n                callback(result);\n            };\n            putTransaction.onabort = onError;\n            putTransaction.onerror = onError;\n\n            if (this.keyPath !== null) { // in-line keys\n                this._addIdPropertyIfNeeded(value);\n                putRequest = putTransaction.objectStore(this.storeName).put(value);\n            } else { // out-of-line keys\n                putRequest = putTransaction.objectStore(this.storeName).put(value, key);\n            }\n            putRequest.onsuccess = function (event) {\n                hasSuccess = true;\n                result = event.target.result;\n            };\n            putRequest.onerror = onError;\n\n            return putTransaction;\n        },\n\n        /**\n         * Retrieves an object from the store. If no entry exists with the given id,\n         * the success handler will be called with null as first and only argument.\n         *\n         * @param {*} key The id of the object to fetch.\n         * @param {Function} [onSuccess] A callback that is called if fetching\n         *  was successful. Will receive the object as only argument.\n         * @param {Function} [onError] A callback that will be called if an error\n         *  occurred during the operation.\n         * @returns {IDBTransaction} The transaction used for this operation.\n         */\n        get: function (key, onSuccess, onError) {\n            onError || (onError = defaultErrorHandler);\n            onSuccess || (onSuccess = defaultSuccessHandler);\n\n            var hasSuccess = false,\n                result = null;\n\n            var getTransaction = this.db.transaction([this.storeName], this.consts.READ_ONLY);\n            getTransaction.oncomplete = function () {\n                var callback = hasSuccess ? onSuccess : onError;\n                callback(result);\n            };\n            getTransaction.onabort = onError;\n            getTransaction.onerror = onError;\n            var getRequest = getTransaction.objectStore(this.storeName).get(key);\n            getRequest.onsuccess = function (event) {\n                hasSuccess = true;\n                result = event.target.result;\n            };\n            getRequest.onerror = onError;\n\n            return getTransaction;\n        },\n\n        /**\n         * Removes an object from the store.\n         *\n         * @param {*} key The id of the object to remove.\n         * @param {Function} [onSuccess] A callback that is called if the removal\n         *  was successful.\n         * @param {Function} [onError] A callback that will be called if an error\n         *  occurred during the operation.\n         * @returns {IDBTransaction} The transaction used for this operation.\n         */\n        remove: function (key, onSuccess, onError) {\n            onError || (onError = defaultErrorHandler);\n            onSuccess || (onSuccess = defaultSuccessHandler);\n\n            var hasSuccess = false,\n                result = null;\n\n            var removeTransaction = this.db.transaction([this.storeName], this.consts.READ_WRITE);\n            removeTransaction.oncomplete = function () {\n                var callback = hasSuccess ? onSuccess : onError;\n                callback(result);\n            };\n            removeTransaction.onabort = onError;\n            removeTransaction.onerror = onError;\n\n            var deleteRequest = removeTransaction.objectStore(this.storeName)['delete'](key);\n            deleteRequest.onsuccess = function (event) {\n                hasSuccess = true;\n                result = event.target.result;\n            };\n            deleteRequest.onerror = onError;\n\n            return removeTransaction;\n        },\n\n        /**\n         * Runs a batch of put and/or remove operations on the store.\n         *\n         * @param {Array} dataArray An array of objects containing the operation to run\n         *  and the data object (for put operations).\n         * @param {Function} [onSuccess] A callback that is called if all operations\n         *  were successful.\n         * @param {Function} [onError] A callback that is called if an error\n         *  occurred during one of the operations.\n         * @returns {IDBTransaction} The transaction used for this operation.\n         */\n        batch: function (dataArray, onSuccess, onError) {\n            onError || (onError = defaultErrorHandler);\n            onSuccess || (onSuccess = defaultSuccessHandler);\n\n            if (Object.prototype.toString.call(dataArray) != '[object Array]') {\n                onError(new Error('dataArray argument must be of type Array.'));\n            } else if (dataArray.length === 0) {\n                return onSuccess(true);\n            }\n\n            var count = dataArray.length;\n            var called = false;\n            var hasSuccess = false;\n\n            var batchTransaction = this.db.transaction([this.storeName], this.consts.READ_WRITE);\n            batchTransaction.oncomplete = function () {\n                var callback = hasSuccess ? onSuccess : onError;\n                callback(hasSuccess);\n            };\n            batchTransaction.onabort = onError;\n            batchTransaction.onerror = onError;\n\n\n            var onItemSuccess = function () {\n                count--;\n                if (count === 0 && !called) {\n                    called = true;\n                    hasSuccess = true;\n                }\n            };\n\n            dataArray.forEach(function (operation) {\n                var type = operation.type;\n                var key = operation.key;\n                var value = operation.value;\n\n                var onItemError = function (err) {\n                    batchTransaction.abort();\n                    if (!called) {\n                        called = true;\n                        onError(err, type, key);\n                    }\n                };\n\n                if (type == 'remove') {\n                    var deleteRequest = batchTransaction.objectStore(this.storeName)['delete'](key);\n                    deleteRequest.onsuccess = onItemSuccess;\n                    deleteRequest.onerror = onItemError;\n                } else if (type == 'put') {\n                    var putRequest;\n                    if (this.keyPath !== null) { // in-line keys\n                        this._addIdPropertyIfNeeded(value);\n                        putRequest = batchTransaction.objectStore(this.storeName).put(value);\n                    } else { // out-of-line keys\n                        putRequest = batchTransaction.objectStore(this.storeName).put(value, key);\n                    }\n                    putRequest.onsuccess = onItemSuccess;\n                    putRequest.onerror = onItemError;\n                }\n            }, this);\n\n            return batchTransaction;\n        },\n\n        /**\n         * Takes an array of objects and stores them in a single transaction.\n         *\n         * @param {Array} dataArray An array of objects to store\n         * @param {Function} [onSuccess] A callback that is called if all operations\n         *  were successful.\n         * @param {Function} [onError] A callback that is called if an error\n         *  occurred during one of the operations.\n         * @returns {IDBTransaction} The transaction used for this operation.\n         */\n        putBatch: function (dataArray, onSuccess, onError) {\n            var batchData = dataArray.map(function (item) {\n                return {type: 'put', value: item};\n            });\n\n            return this.batch(batchData, onSuccess, onError);\n        },\n\n        /**\n         * Like putBatch, takes an array of objects and stores them in a single\n         * transaction, but allows processing of the result values.  Returns the\n         * processed records containing the key for newly created records to the\n         * onSuccess calllback instead of only returning true or false for success.\n         * In addition, added the option for the caller to specify a key field that\n         * should be set to the newly created key.\n         *\n         * @param {Array} dataArray An array of objects to store\n         * @param {Object} [options] An object containing optional options\n         * @param {String} [options.keyField=this.keyPath] Specifies a field in the record to update\n         *  with the auto-incrementing key. Defaults to the store's keyPath.\n         * @param {Function} [onSuccess] A callback that is called if all operations\n         *  were successful.\n         * @param {Function} [onError] A callback that is called if an error\n         *  occurred during one of the operations.\n         * @returns {IDBTransaction} The transaction used for this operation.\n         *\n         */\n        upsertBatch: function (dataArray, options, onSuccess, onError) {\n            // handle `dataArray, onSuccess, onError` signature\n            if (typeof options == 'function') {\n                onSuccess = options;\n                onError = onSuccess;\n                options = {};\n            }\n\n            onError || (onError = defaultErrorHandler);\n            onSuccess || (onSuccess = defaultSuccessHandler);\n            options || (options = {});\n\n            if (Object.prototype.toString.call(dataArray) != '[object Array]') {\n                onError(new Error('dataArray argument must be of type Array.'));\n            }\n\n            var keyField = options.keyField || this.keyPath;\n            var count = dataArray.length;\n            var called = false;\n            var hasSuccess = false;\n            var index = 0; // assume success callbacks are executed in order\n\n            var batchTransaction = this.db.transaction([this.storeName], this.consts.READ_WRITE);\n            batchTransaction.oncomplete = function () {\n                if (hasSuccess) {\n                    onSuccess(dataArray);\n                } else {\n                    onError(false);\n                }\n            };\n            batchTransaction.onabort = onError;\n            batchTransaction.onerror = onError;\n\n            var onItemSuccess = function (event) {\n                var record = dataArray[index++];\n                record[keyField] = event.target.result;\n\n                count--;\n                if (count === 0 && !called) {\n                    called = true;\n                    hasSuccess = true;\n                }\n            };\n\n            dataArray.forEach(function (record) {\n                var key = record.key;\n\n                var onItemError = function (err) {\n                    batchTransaction.abort();\n                    if (!called) {\n                        called = true;\n                        onError(err);\n                    }\n                };\n\n                var putRequest;\n                if (this.keyPath !== null) { // in-line keys\n                    this._addIdPropertyIfNeeded(record);\n                    putRequest = batchTransaction.objectStore(this.storeName).put(record);\n                } else { // out-of-line keys\n                    putRequest = batchTransaction.objectStore(this.storeName).put(record, key);\n                }\n                putRequest.onsuccess = onItemSuccess;\n                putRequest.onerror = onItemError;\n            }, this);\n\n            return batchTransaction;\n        },\n\n        /**\n         * Takes an array of keys and removes matching objects in a single\n         * transaction.\n         *\n         * @param {Array} keyArray An array of keys to remove\n         * @param {Function} [onSuccess] A callback that is called if all operations\n         *  were successful.\n         * @param {Function} [onError] A callback that is called if an error\n         *  occurred during one of the operations.\n         * @returns {IDBTransaction} The transaction used for this operation.\n         */\n        removeBatch: function (keyArray, onSuccess, onError) {\n            var batchData = keyArray.map(function (key) {\n                return {type: 'remove', key: key};\n            });\n\n            return this.batch(batchData, onSuccess, onError);\n        },\n\n        /**\n         * Takes an array of keys and fetches matching objects\n         *\n         * @param {Array} keyArray An array of keys identifying the objects to fetch\n         * @param {Function} [onSuccess] A callback that is called if all operations\n         *  were successful.\n         * @param {Function} [onError] A callback that is called if an error\n         *  occurred during one of the operations.\n         * @param {String} [arrayType='sparse'] The type of array to pass to the\n         *  success handler. May be one of 'sparse', 'dense' or 'skip'. Defaults to\n         *  'sparse'. This parameter specifies how to handle the situation if a get\n         *  operation did not throw an error, but there was no matching object in\n         *  the database. In most cases, 'sparse' provides the most desired\n         *  behavior. See the examples for details.\n         * @returns {IDBTransaction} The transaction used for this operation.\n         * @example\n         // given that there are two objects in the database with the keypath\n         // values 1 and 2, and the call looks like this:\n         myStore.getBatch([1, 5, 2], onError, function (data) { â€¦ }, arrayType);\n\n         // this is what the `data` array will be like:\n\n         // arrayType == 'sparse':\n         // data is a sparse array containing two entries and having a length of 3:\n         [Object, 2: Object]\n         0: Object\n         2: Object\n         length: 3\n         // calling forEach on data will result in the callback being called two\n         // times, with the index parameter matching the index of the key in the\n         // keyArray.\n\n         // arrayType == 'dense':\n         // data is a dense array containing three entries and having a length of 3,\n         // where data[1] is of type undefined:\n         [Object, undefined, Object]\n         0: Object\n         1: undefined\n         2: Object\n         length: 3\n         // calling forEach on data will result in the callback being called three\n         // times, with the index parameter matching the index of the key in the\n         // keyArray, but the second call will have undefined as first argument.\n\n         // arrayType == 'skip':\n         // data is a dense array containing two entries and having a length of 2:\n         [Object, Object]\n         0: Object\n         1: Object\n         length: 2\n         // calling forEach on data will result in the callback being called two\n         // times, with the index parameter not matching the index of the key in the\n         // keyArray.\n         */\n        getBatch: function (keyArray, onSuccess, onError, arrayType) {\n            onError || (onError = defaultErrorHandler);\n            onSuccess || (onSuccess = defaultSuccessHandler);\n            arrayType || (arrayType = 'sparse');\n\n            if (Object.prototype.toString.call(keyArray) != '[object Array]') {\n                onError(new Error('keyArray argument must be of type Array.'));\n            } else if (keyArray.length === 0) {\n                return onSuccess([]);\n            }\n\n            var data = [];\n            var count = keyArray.length;\n            var called = false;\n            var hasSuccess = false;\n            var result = null;\n\n            var batchTransaction = this.db.transaction([this.storeName], this.consts.READ_ONLY);\n            batchTransaction.oncomplete = function () {\n                var callback = hasSuccess ? onSuccess : onError;\n                callback(result);\n            };\n            batchTransaction.onabort = onError;\n            batchTransaction.onerror = onError;\n\n            var onItemSuccess = function (event) {\n                if (event.target.result || arrayType == 'dense') {\n                    data.push(event.target.result);\n                } else if (arrayType == 'sparse') {\n                    data.length++;\n                }\n                count--;\n                if (count === 0) {\n                    called = true;\n                    hasSuccess = true;\n                    result = data;\n                }\n            };\n\n            keyArray.forEach(function (key) {\n\n                var onItemError = function (err) {\n                    called = true;\n                    result = err;\n                    onError(err);\n                    batchTransaction.abort();\n                };\n\n                var getRequest = batchTransaction.objectStore(this.storeName).get(key);\n                getRequest.onsuccess = onItemSuccess;\n                getRequest.onerror = onItemError;\n\n            }, this);\n\n            return batchTransaction;\n        },\n\n        /**\n         * Fetches all entries in the store.\n         *\n         * @param {Function} [onSuccess] A callback that is called if the operation\n         *  was successful. Will receive an array of objects.\n         * @param {Function} [onError] A callback that will be called if an error\n         *  occurred during the operation.\n         * @returns {IDBTransaction} The transaction used for this operation.\n         */\n        getAll: function (onSuccess, onError) {\n            onError || (onError = defaultErrorHandler);\n            onSuccess || (onSuccess = defaultSuccessHandler);\n            var getAllTransaction = this.db.transaction([this.storeName], this.consts.READ_ONLY);\n            var store = getAllTransaction.objectStore(this.storeName);\n            if (store.getAll) {\n                this._getAllNative(getAllTransaction, store, onSuccess, onError);\n            } else {\n                this._getAllCursor(getAllTransaction, store, onSuccess, onError);\n            }\n\n            return getAllTransaction;\n        },\n\n        /**\n         * Implements getAll for IDB implementations that have a non-standard\n         * getAll() method.\n         *\n         * @param {IDBTransaction} getAllTransaction An open READ transaction.\n         * @param {IDBObjectStore} store A reference to the store.\n         * @param {Function} onSuccess A callback that will be called if the\n         *  operation was successful.\n         * @param {Function} onError A callback that will be called if an\n         *  error occurred during the operation.\n         * @private\n         */\n        _getAllNative: function (getAllTransaction, store, onSuccess, onError) {\n            var hasSuccess = false,\n                result = null;\n\n            getAllTransaction.oncomplete = function () {\n                var callback = hasSuccess ? onSuccess : onError;\n                callback(result);\n            };\n            getAllTransaction.onabort = onError;\n            getAllTransaction.onerror = onError;\n\n            var getAllRequest = store.getAll();\n            getAllRequest.onsuccess = function (event) {\n                hasSuccess = true;\n                result = event.target.result;\n            };\n            getAllRequest.onerror = onError;\n        },\n\n        /**\n         * Implements getAll for IDB implementations that do not have a getAll()\n         * method.\n         *\n         * @param {IDBTransaction} getAllTransaction An open READ transaction.\n         * @param {IDBObjectStore} store A reference to the store.\n         * @param {Function} onSuccess A callback that will be called if the\n         *  operation was successful.\n         * @param {Function} onError A callback that will be called if an\n         *  error occurred during the operation.\n         * @private\n         */\n        _getAllCursor: function (getAllTransaction, store, onSuccess, onError) {\n            var all = [],\n                hasSuccess = false,\n                result = null;\n\n            getAllTransaction.oncomplete = function () {\n                var callback = hasSuccess ? onSuccess : onError;\n                callback(result);\n            };\n            getAllTransaction.onabort = onError;\n            getAllTransaction.onerror = onError;\n\n            var cursorRequest = store.openCursor();\n            cursorRequest.onsuccess = function (event) {\n                var cursor = event.target.result;\n                if (cursor) {\n                    all.push(cursor.value);\n                    cursor['continue']();\n                }\n                else {\n                    hasSuccess = true;\n                    result = all;\n                }\n            };\n            cursorRequest.onError = onError;\n        },\n\n        /**\n         * Clears the store, i.e. deletes all entries in the store.\n         *\n         * @param {Function} [onSuccess] A callback that will be called if the\n         *  operation was successful.\n         * @param {Function} [onError] A callback that will be called if an\n         *  error occurred during the operation.\n         * @returns {IDBTransaction} The transaction used for this operation.\n         */\n        clear: function (onSuccess, onError) {\n            onError || (onError = defaultErrorHandler);\n            onSuccess || (onSuccess = defaultSuccessHandler);\n\n            var hasSuccess = false,\n                result = null;\n\n            var clearTransaction = this.db.transaction([this.storeName], this.consts.READ_WRITE);\n            clearTransaction.oncomplete = function () {\n                var callback = hasSuccess ? onSuccess : onError;\n                callback(result);\n            };\n            clearTransaction.onabort = onError;\n            clearTransaction.onerror = onError;\n\n            var clearRequest = clearTransaction.objectStore(this.storeName).clear();\n            clearRequest.onsuccess = function (event) {\n                hasSuccess = true;\n                result = event.target.result;\n            };\n            clearRequest.onerror = onError;\n\n            return clearTransaction;\n        },\n\n        /**\n         * Checks if an id property needs to present on a object and adds one if\n         * necessary.\n         *\n         * @param {Object} dataObj The data object that is about to be stored\n         * @private\n         */\n        _addIdPropertyIfNeeded: function (dataObj) {\n            if (typeof dataObj[this.keyPath] == 'undefined') {\n                dataObj[this.keyPath] = this._insertIdCount++ + Date.now();\n            }\n        },\n\n        /************\n         * indexing *\n         ************/\n\n        /**\n         * Returns a DOMStringList of index names of the store.\n         *\n         * @return {DOMStringList} The list of index names\n         */\n        getIndexList: function () {\n            return this.store.indexNames;\n        },\n\n        /**\n         * Checks if an index with the given name exists in the store.\n         *\n         * @param {String} indexName The name of the index to look for\n         * @return {Boolean} Whether the store contains an index with the given name\n         */\n        hasIndex: function (indexName) {\n            return this.store.indexNames.contains(indexName);\n        },\n\n        /**\n         * Normalizes an object containing index data and assures that all\n         * properties are set.\n         *\n         * @param {Object} indexData The index data object to normalize\n         * @param {String} indexData.name The name of the index\n         * @param {String} [indexData.keyPath] The key path of the index\n         * @param {Boolean} [indexData.unique] Whether the index is unique\n         * @param {Boolean} [indexData.multiEntry] Whether the index is multi entry\n         */\n        normalizeIndexData: function (indexData) {\n            indexData.keyPath = indexData.keyPath || indexData.name;\n            indexData.unique = !!indexData.unique;\n            indexData.multiEntry = !!indexData.multiEntry;\n        },\n\n        /**\n         * Checks if an actual index complies with an expected index.\n         *\n         * @param {IDBIndex} actual The actual index found in the store\n         * @param {Object} expected An Object describing an expected index\n         * @return {Boolean} Whether both index definitions are identical\n         */\n        indexComplies: function (actual, expected) {\n            var complies = ['keyPath', 'unique', 'multiEntry'].every(function (key) {\n                // IE10 returns undefined for no multiEntry\n                if (key == 'multiEntry' && actual[key] === undefined && expected[key] === false) {\n                    return true;\n                }\n                // Compound keys\n                if (key == 'keyPath' && Object.prototype.toString.call(expected[key]) == '[object Array]') {\n                    var exp = expected.keyPath;\n                    var act = actual.keyPath;\n\n                    // IE10 can't handle keyPath sequences and stores them as a string.\n                    // The index will be unusable there, but let's still return true if\n                    // the keyPath sequence matches.\n                    if (typeof act == 'string') {\n                        return exp.toString() == act;\n                    }\n\n                    // Chrome/Opera stores keyPath squences as DOMStringList, Firefox\n                    // as Array\n                    if (!(typeof act.contains == 'function' || typeof act.indexOf == 'function')) {\n                        return false;\n                    }\n\n                    if (act.length !== exp.length) {\n                        return false;\n                    }\n\n                    for (var i = 0, m = exp.length; i < m; i++) {\n                        if (!( (act.contains && act.contains(exp[i])) || act.indexOf(exp[i] !== -1) )) {\n                            return false;\n                        }\n                    }\n                    return true;\n                }\n                return expected[key] == actual[key];\n            });\n            return complies;\n        },\n\n        /**********\n         * cursor *\n         **********/\n\n        /**\n         * Iterates over the store using the given options and calling onItem\n         * for each entry matching the options.\n         *\n         * @param {Function} onItem A callback to be called for each match\n         * @param {Object} [options] An object defining specific options\n         * @param {String} [options.index=null] A name of an IDBIndex to operate on\n         * @param {String} [options.order=ASC] The order in which to provide the\n         *  results, can be 'DESC' or 'ASC'\n         * @param {Boolean} [options.autoContinue=true] Whether to automatically\n         *  iterate the cursor to the next result\n         * @param {Boolean} [options.filterDuplicates=false] Whether to exclude\n         *  duplicate matches\n         * @param {IDBKeyRange} [options.keyRange=null] An IDBKeyRange to use\n         * @param {Boolean} [options.writeAccess=false] Whether grant write access\n         *  to the store in the onItem callback\n         * @param {Function} [options.onEnd=null] A callback to be called after\n         *  iteration has ended\n         * @param {Function} [options.onError=throw] A callback to be called\n         *  if an error occurred during the operation.\n         * @param {Number} [options.limit=Infinity] Limit the number of returned\n         *  results to this number\n         * @param {Number} [options.offset=0] Skip the provided number of results\n         *  in the resultset\n         * @param {Boolean} [options.allowItemRejection=false] Allows the onItem\n         * function to return a Boolean to accept or reject the current item\n         * @returns {IDBTransaction} The transaction used for this operation.\n         */\n        iterate: function (onItem, options) {\n            options = mixin({\n                index: null,\n                order: 'ASC',\n                autoContinue: true,\n                filterDuplicates: false,\n                keyRange: null,\n                writeAccess: false,\n                onEnd: null,\n                onError: defaultErrorHandler,\n                limit: Infinity,\n                offset: 0,\n                allowItemRejection: false\n            }, options || {});\n\n            var directionType = options.order.toLowerCase() == 'desc' ? 'PREV' : 'NEXT';\n            if (options.filterDuplicates) {\n                directionType += '_NO_DUPLICATE';\n            }\n\n            var hasSuccess = false;\n            var cursorTransaction = this.db.transaction([this.storeName], this.consts[options.writeAccess ? 'READ_WRITE' : 'READ_ONLY']);\n            var cursorTarget = cursorTransaction.objectStore(this.storeName);\n            if (options.index) {\n                cursorTarget = cursorTarget.index(options.index);\n            }\n            var recordCount = 0;\n\n            cursorTransaction.oncomplete = function () {\n                if (!hasSuccess) {\n                    options.onError(null);\n                    return;\n                }\n                if (options.onEnd) {\n                    options.onEnd();\n                } else {\n                    onItem(null);\n                }\n            };\n            cursorTransaction.onabort = options.onError;\n            cursorTransaction.onerror = options.onError;\n\n            var cursorRequest = cursorTarget.openCursor(options.keyRange, this.consts[directionType]);\n            cursorRequest.onerror = options.onError;\n            cursorRequest.onsuccess = function (event) {\n                var cursor = event.target.result;\n                if (cursor) {\n                    if (options.offset) {\n                        cursor.advance(options.offset);\n                        options.offset = 0;\n                    } else {\n                        var onItemReturn = onItem(cursor.value, cursor, cursorTransaction);\n                        if (!options.allowItemRejection || onItemReturn !== false) {\n                            recordCount++;\n                        }\n                        if (options.autoContinue) {\n                            if (recordCount + options.offset < options.limit) {\n                                cursor['continue']();\n                            } else {\n                                hasSuccess = true;\n                            }\n                        }\n                    }\n                } else {\n                    hasSuccess = true;\n                }\n            };\n\n            return cursorTransaction;\n        },\n\n        /**\n         * Runs a query against the store and passes an array containing matched\n         * objects to the success handler.\n         *\n         * @param {Function} onSuccess A callback to be called when the operation\n         *  was successful.\n         * @param {Object} [options] An object defining specific options\n         * @param {String} [options.index=null] A name of an IDBIndex to operate on\n         * @param {String} [options.order=ASC] The order in which to provide the\n         *  results, can be 'DESC' or 'ASC'\n         * @param {Boolean} [options.filterDuplicates=false] Whether to exclude\n         *  duplicate matches\n         * @param {IDBKeyRange} [options.keyRange=null] An IDBKeyRange to use\n         * @param {Function} [options.onError=throw] A callback to be called\n         *  if an error occurred during the operation.\n         * @param {Number} [options.limit=Infinity] Limit the number of returned\n         *  results to this number\n         * @param {Number} [options.offset=0] Skip the provided number of results\n         *  in the resultset\n         * @param {Function} [options.filter=null] A custom filter function to\n         *  apply to query resuts before returning. Must return `false` to reject\n         *  an item. Can be combined with keyRanges.\n         * @returns {IDBTransaction} The transaction used for this operation.\n         */\n        query: function (onSuccess, options) {\n            var result = [],\n                processedItems = 0;\n            options = options || {};\n            options.autoContinue = true;\n            options.writeAccess = false;\n            options.allowItemRejection = !!options.filter;\n            options.onEnd = function () {\n                onSuccess(result, processedItems);\n            };\n            return this.iterate(function (item) {\n                processedItems++;\n                var accept = options.filter ? options.filter(item) : true;\n                if (accept !== false) {\n                    result.push(item);\n                }\n                return accept;\n            }, options);\n        },\n\n        /**\n         *\n         * Runs a query against the store, but only returns the number of matches\n         * instead of the matches itself.\n         *\n         * @param {Function} onSuccess A callback to be called if the opration\n         *  was successful.\n         * @param {Object} [options] An object defining specific options\n         * @param {String} [options.index=null] A name of an IDBIndex to operate on\n         * @param {IDBKeyRange} [options.keyRange=null] An IDBKeyRange to use\n         * @param {Function} [options.onError=throw] A callback to be called if an error\n         *  occurred during the operation.\n         * @returns {IDBTransaction} The transaction used for this operation.\n         */\n        count: function (onSuccess, options) {\n\n            options = mixin({\n                index: null,\n                keyRange: null\n            }, options || {});\n\n            var onError = options.onError || defaultErrorHandler;\n\n            var hasSuccess = false,\n                result = null;\n\n            var cursorTransaction = this.db.transaction([this.storeName], this.consts.READ_ONLY);\n            cursorTransaction.oncomplete = function () {\n                var callback = hasSuccess ? onSuccess : onError;\n                callback(result);\n            };\n            cursorTransaction.onabort = onError;\n            cursorTransaction.onerror = onError;\n\n            var cursorTarget = cursorTransaction.objectStore(this.storeName);\n            if (options.index) {\n                cursorTarget = cursorTarget.index(options.index);\n            }\n            var countRequest = cursorTarget.count(options.keyRange);\n            countRequest.onsuccess = function (evt) {\n                hasSuccess = true;\n                result = evt.target.result;\n            };\n            countRequest.onError = onError;\n\n            return cursorTransaction;\n        },\n\n        /**************/\n        /* key ranges */\n        /**************/\n\n        /**\n         * Creates a key range using specified options. This key range can be\n         * handed over to the count() and iterate() methods.\n         *\n         * Note: You must provide at least one or both of \"lower\" or \"upper\" value.\n         *\n         * @param {Object} options The options for the key range to create\n         * @param {*} [options.lower] The lower bound\n         * @param {Boolean} [options.excludeLower] Whether to exclude the lower\n         *  bound passed in options.lower from the key range\n         * @param {*} [options.upper] The upper bound\n         * @param {Boolean} [options.excludeUpper] Whether to exclude the upper\n         *  bound passed in options.upper from the key range\n         * @param {*} [options.only] A single key value. Use this if you need a key\n         *  range that only includes one value for a key. Providing this\n         *  property invalidates all other properties.\n         * @return {IDBKeyRange} The IDBKeyRange representing the specified options\n         */\n        makeKeyRange: function (options) {\n            /*jshint onecase:true */\n            var keyRange,\n                hasLower = typeof options.lower != 'undefined',\n                hasUpper = typeof options.upper != 'undefined',\n                isOnly = typeof options.only != 'undefined';\n\n            switch (true) {\n                case isOnly:\n                    keyRange = this.keyRange.only(options.only);\n                    break;\n                case hasLower && hasUpper:\n                    keyRange = this.keyRange.bound(options.lower, options.upper, options.excludeLower, options.excludeUpper);\n                    break;\n                case hasLower:\n                    keyRange = this.keyRange.lowerBound(options.lower, options.excludeLower);\n                    break;\n                case hasUpper:\n                    keyRange = this.keyRange.upperBound(options.upper, options.excludeUpper);\n                    break;\n                default:\n                    throw new Error('Cannot create KeyRange. Provide one or both of \"lower\" or \"upper\" value, or an \"only\" value.');\n            }\n\n            return keyRange;\n\n        }\n\n    };\n\n    /** helpers **/\n    var empty = {};\n\n    function mixin (target, source) {\n        var name, s;\n        for (name in source) {\n            s = source[name];\n            if (s !== empty[name] && s !== target[name]) {\n                target[name] = s;\n            }\n        }\n        return target;\n    }\n\n    function hasVersionError(errorEvent) {\n        if ('error' in errorEvent.target) {\n            return errorEvent.target.error.name == 'VersionError';\n        } else if ('errorCode' in errorEvent.target) {\n            return errorEvent.target.errorCode == 12;\n        }\n        return false;\n    }\n\n    IDBStore.prototype = proto;\n    IDBStore.version = proto.version;\n\n    return IDBStore;\n\n}, this);\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}