{"ast":null,"code":"require(\"core-js/modules/es.error.cause.js\");\n\nvar http = require('http'),\n    https = require('https'),\n    url = require('url'),\n    Serializer = require('./serializer'),\n    Deserializer = require('./deserializer'),\n    Cookies = require('./cookies');\n/**\n * Creates a Client object for making XML-RPC method calls.\n *\n * @constructor\n * @param {Object|String} options - Server options to make the HTTP request to.\n *                                  Either a URI string\n *                                  (e.g. 'http://localhost:9090') or an object\n *                                  with fields:\n *   - {String} host              - (optional)\n *   - {Number} port\n *   - {String} url               - (optional) - may be used instead of host/port pair\n *   - {Boolean} cookies          - (optional) - if true then cookies returned by server will be stored and sent back on the next calls.\n *                                  Also it will be possible to access/manipulate cookies via #setCookie/#getCookie methods\n * @param {Boolean} isSecure      - True if using https for making calls,\n *                                  otherwise false.\n * @return {Client}\n */\n\n\nfunction Client(options, isSecure) {\n  // Invokes with new if called without\n  if (false === this instanceof Client) {\n    return new Client(options, isSecure);\n  } // If a string URI is passed in, converts to URI fields\n\n\n  if (typeof options === 'string') {\n    options = url.parse(options);\n    options.host = options.hostname;\n    options.path = options.pathname;\n  }\n\n  if (typeof options.url !== 'undefined') {\n    var parsedUrl = url.parse(options.url);\n    options.host = parsedUrl.hostname;\n    options.path = parsedUrl.pathname;\n    options.port = parsedUrl.port;\n  } // Set the HTTP request headers\n\n\n  var headers = {\n    'User-Agent': 'NodeJS XML-RPC Client',\n    'Content-Type': 'text/xml',\n    'Accept': 'text/xml',\n    'Accept-Charset': 'UTF8',\n    'Connection': 'Keep-Alive'\n  };\n  options.headers = options.headers || {};\n\n  if (options.headers.Authorization == null && options.basic_auth != null && options.basic_auth.user != null && options.basic_auth.pass != null) {\n    var auth = options.basic_auth.user + ':' + options.basic_auth.pass;\n    options.headers['Authorization'] = 'Basic ' + new Buffer(auth).toString('base64');\n  }\n\n  for (var attribute in headers) {\n    if (options.headers[attribute] === undefined) {\n      options.headers[attribute] = headers[attribute];\n    }\n  }\n\n  options.method = 'POST';\n  this.options = options;\n  this.isSecure = isSecure;\n  this.headersProcessors = {\n    processors: [],\n    composeRequest: function (headers) {\n      this.processors.forEach(function (p) {\n        p.composeRequest(headers);\n      });\n    },\n    parseResponse: function (headers) {\n      this.processors.forEach(function (p) {\n        p.parseResponse(headers);\n      });\n    }\n  };\n\n  if (options.cookies) {\n    this.cookies = new Cookies();\n    this.headersProcessors.processors.unshift(this.cookies);\n  }\n}\n/**\n * Makes an XML-RPC call to the server specified by the constructor's options.\n *\n * @param {String} method     - The method name.\n * @param {Array} params      - Params to send in the call.\n * @param {Function} callback - function(error, value) { ... }\n *   - {Object|null} error    - Any errors when making the call, otherwise null.\n *   - {mixed} value          - The value returned in the method response.\n */\n\n\nClient.prototype.methodCall = function methodCall(method, params, callback) {\n  var options = this.options;\n  var xml = Serializer.serializeMethodCall(method, params, options.encoding);\n  var transport = this.isSecure ? https : http;\n  options.headers['Content-Length'] = Buffer.byteLength(xml, 'utf8');\n  this.headersProcessors.composeRequest(options.headers);\n  var request = transport.request(options, function (response) {\n    var body = [];\n    response.on('data', function (chunk) {\n      body.push(chunk);\n    });\n\n    function __enrichError(err) {\n      Object.defineProperty(err, 'req', {\n        value: request\n      });\n      Object.defineProperty(err, 'res', {\n        value: response\n      });\n      Object.defineProperty(err, 'body', {\n        value: body.join('')\n      });\n      return err;\n    }\n\n    if (response.statusCode == 404) {\n      callback(__enrichError(new Error('Not Found')));\n    } else {\n      this.headersProcessors.parseResponse(response.headers);\n      var deserializer = new Deserializer(options.responseEncoding);\n      deserializer.deserializeMethodResponse(response, function (err, result) {\n        if (err) {\n          err = __enrichError(err);\n        }\n\n        callback(err, result);\n      });\n    }\n  }.bind(this));\n  request.on('error', callback);\n  request.write(xml, 'utf8');\n  request.end();\n};\n/**\n * Gets the cookie value by its name. The latest value received from servr with 'Set-Cookie' header is returned\n * Note that method throws an error if cookies were not turned on during client creation (see comments for constructor)\n *\n * @param {String} name name of the cookie to be obtained or changed\n * @return {*} cookie's value\n */\n\n\nClient.prototype.getCookie = function getCookie(name) {\n  if (!this.cookies) {\n    throw 'Cookies support is not turned on for this client instance';\n  }\n\n  return this.cookies.get(name);\n};\n/**\n * Sets the cookie value by its name. The cookie will be sent to the server during the next xml-rpc call.\n * The method returns client itself, so it is possible to chain calls like the following:\n *\n * <code>\n *   client.cookie('login', 'alex').cookie('password', '123');\n * </code>\n *\n * Note that method throws an error if cookies were not turned on during client creation (see comments for constructor)\n *\n * @param {String} name name of the cookie to be changed\n * @param {String} value value to be set.\n * @return {*} client object itself\n */\n\n\nClient.prototype.setCookie = function setCookie(name, value) {\n  if (!this.cookies) {\n    throw 'Cookies support is not turned on for this client instance';\n  }\n\n  this.cookies.set(name, value);\n  return this;\n};\n\nmodule.exports = Client;","map":{"version":3,"names":["http","require","https","url","Serializer","Deserializer","Cookies","Client","options","isSecure","parse","host","hostname","path","pathname","parsedUrl","port","headers","Authorization","basic_auth","user","pass","auth","Buffer","toString","attribute","undefined","method","headersProcessors","processors","composeRequest","forEach","p","parseResponse","cookies","unshift","prototype","methodCall","params","callback","xml","serializeMethodCall","encoding","transport","byteLength","request","response","body","on","chunk","push","__enrichError","err","Object","defineProperty","value","join","statusCode","Error","deserializer","responseEncoding","deserializeMethodResponse","result","bind","write","end","getCookie","name","get","setCookie","set","module","exports"],"sources":["/Users/terwer/Documents/mydocs/my-note-docker/workspace/SiYuan/data/widgets/publisher/src/publisher/node_modules/xmlrpc/lib/client.js"],"sourcesContent":["var http         = require('http')\n  , https        = require('https')\n  , url          = require('url')\n  , Serializer   = require('./serializer')\n  , Deserializer = require('./deserializer')\n  , Cookies      = require('./cookies')\n\n/**\n * Creates a Client object for making XML-RPC method calls.\n *\n * @constructor\n * @param {Object|String} options - Server options to make the HTTP request to.\n *                                  Either a URI string\n *                                  (e.g. 'http://localhost:9090') or an object\n *                                  with fields:\n *   - {String} host              - (optional)\n *   - {Number} port\n *   - {String} url               - (optional) - may be used instead of host/port pair\n *   - {Boolean} cookies          - (optional) - if true then cookies returned by server will be stored and sent back on the next calls.\n *                                  Also it will be possible to access/manipulate cookies via #setCookie/#getCookie methods\n * @param {Boolean} isSecure      - True if using https for making calls,\n *                                  otherwise false.\n * @return {Client}\n */\nfunction Client(options, isSecure) {\n\n  // Invokes with new if called without\n  if (false === (this instanceof Client)) {\n    return new Client(options, isSecure)\n  }\n\n  // If a string URI is passed in, converts to URI fields\n  if (typeof options === 'string') {\n    options = url.parse(options)\n    options.host = options.hostname\n    options.path = options.pathname\n  }\n\n  if (typeof options.url !== 'undefined') {\n    var parsedUrl = url.parse(options.url);\n    options.host = parsedUrl.hostname;\n    options.path = parsedUrl.pathname;\n    options.port = parsedUrl.port;\n  }\n\n  // Set the HTTP request headers\n  var headers = {\n    'User-Agent'     : 'NodeJS XML-RPC Client'\n  , 'Content-Type'   : 'text/xml'\n  , 'Accept'         : 'text/xml'\n  , 'Accept-Charset' : 'UTF8'\n  , 'Connection'     : 'Keep-Alive'\n  }\n  options.headers = options.headers || {}\n\n  if (options.headers.Authorization == null &&\n      options.basic_auth != null &&\n      options.basic_auth.user != null &&\n      options.basic_auth.pass != null)\n  {\n    var auth = options.basic_auth.user + ':' + options.basic_auth.pass\n    options.headers['Authorization'] = 'Basic ' + new Buffer(auth).toString('base64')\n  }\n\n  for (var attribute in headers) {\n    if (options.headers[attribute] === undefined) {\n      options.headers[attribute] = headers[attribute]\n    }\n  }\n\n  options.method = 'POST'\n  this.options = options\n\n  this.isSecure = isSecure\n  this.headersProcessors = {\n    processors: [],\n    composeRequest: function(headers) {\n      this.processors.forEach(function(p) {p.composeRequest(headers);})\n    },\n    parseResponse: function(headers) {\n      this.processors.forEach(function(p) {p.parseResponse(headers);})\n    }\n  };\n  if (options.cookies) {\n    this.cookies = new Cookies();\n    this.headersProcessors.processors.unshift(this.cookies);\n  }\n}\n\n/**\n * Makes an XML-RPC call to the server specified by the constructor's options.\n *\n * @param {String} method     - The method name.\n * @param {Array} params      - Params to send in the call.\n * @param {Function} callback - function(error, value) { ... }\n *   - {Object|null} error    - Any errors when making the call, otherwise null.\n *   - {mixed} value          - The value returned in the method response.\n */\nClient.prototype.methodCall = function methodCall(method, params, callback) {\n  var options   = this.options\n  var xml       = Serializer.serializeMethodCall(method, params, options.encoding)\n  var transport = this.isSecure ? https : http\n\n  options.headers['Content-Length'] = Buffer.byteLength(xml, 'utf8')\n  this.headersProcessors.composeRequest(options.headers)\n  var request = transport.request(options, function(response) {\n\n    var body = []\n    response.on('data', function (chunk) { body.push(chunk) })\n\n    function __enrichError (err) {\n      Object.defineProperty(err, 'req', { value: request })\n      Object.defineProperty(err, 'res', { value: response })\n      Object.defineProperty(err, 'body', { value: body.join('') })\n      return err\n    }\n\n    if (response.statusCode == 404) {\n      callback(__enrichError(new Error('Not Found')))\n    }\n    else {\n      this.headersProcessors.parseResponse(response.headers)\n\n      var deserializer = new Deserializer(options.responseEncoding)\n\n      deserializer.deserializeMethodResponse(response, function(err, result) {\n        if (err) {\n          err = __enrichError(err)\n        }\n        callback(err, result)\n      })\n    }\n  }.bind(this))\n\n  request.on('error', callback)\n  request.write(xml, 'utf8')\n  request.end()\n}\n\n/**\n * Gets the cookie value by its name. The latest value received from servr with 'Set-Cookie' header is returned\n * Note that method throws an error if cookies were not turned on during client creation (see comments for constructor)\n *\n * @param {String} name name of the cookie to be obtained or changed\n * @return {*} cookie's value\n */\nClient.prototype.getCookie = function getCookie(name) {\n  if (!this.cookies) {\n    throw 'Cookies support is not turned on for this client instance';\n  }\n  return this.cookies.get(name);\n}\n\n/**\n * Sets the cookie value by its name. The cookie will be sent to the server during the next xml-rpc call.\n * The method returns client itself, so it is possible to chain calls like the following:\n *\n * <code>\n *   client.cookie('login', 'alex').cookie('password', '123');\n * </code>\n *\n * Note that method throws an error if cookies were not turned on during client creation (see comments for constructor)\n *\n * @param {String} name name of the cookie to be changed\n * @param {String} value value to be set.\n * @return {*} client object itself\n */\nClient.prototype.setCookie = function setCookie(name, value) {\n  if (!this.cookies) {\n    throw 'Cookies support is not turned on for this client instance';\n  }\n  this.cookies.set(name, value);\n  return this;\n}\n\nmodule.exports = Client\n\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}