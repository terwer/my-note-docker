{"ast":null,"code":"'use strict';\n\nfunction objectToString(o) {\n  return Object.prototype.toString.call(o);\n} // shim for Node's 'util' package\n// DO NOT REMOVE THIS! It is required for compatibility with EnderJS (http://enderjs.com/).\n\n\nvar util = {\n  isArray: function (ar) {\n    return Array.isArray(ar) || typeof ar === 'object' && objectToString(ar) === '[object Array]';\n  },\n  isDate: function (d) {\n    return typeof d === 'object' && objectToString(d) === '[object Date]';\n  },\n  isRegExp: function (re) {\n    return typeof re === 'object' && objectToString(re) === '[object RegExp]';\n  },\n  getRegExpFlags: function (re) {\n    var flags = '';\n    re.global && (flags += 'g');\n    re.ignoreCase && (flags += 'i');\n    re.multiline && (flags += 'm');\n    return flags;\n  }\n};\nif (typeof module === 'object') module.exports = clone;\n/**\n * Clones (copies) an Object using deep copying.\n *\n * This function supports circular references by default, but if you are certain\n * there are no circular references in your object, you can save some CPU time\n * by calling clone(obj, false).\n *\n * Caution: if `circular` is false and `parent` contains circular references,\n * your program may enter an infinite loop and crash.\n *\n * @param `parent` - the object to be cloned\n * @param `circular` - set to true if the object to be cloned may contain\n *    circular references. (optional - true by default)\n * @param `depth` - set to a number if the object is only to be cloned to\n *    a particular depth. (optional - defaults to Infinity)\n * @param `prototype` - sets the prototype to be used when cloning an object.\n *    (optional - defaults to parent prototype).\n*/\n\nfunction clone(parent, circular, depth, prototype) {\n  // maintain two arrays for circular references, where corresponding parents\n  // and children have the same index\n  var allParents = [];\n  var allChildren = [];\n  var useBuffer = typeof Buffer != 'undefined';\n  if (typeof circular == 'undefined') circular = true;\n  if (typeof depth == 'undefined') depth = Infinity; // recurse this function so we don't reset allParents and allChildren\n\n  function _clone(parent, depth) {\n    // cloning null always returns null\n    if (parent === null) return null;\n    if (depth == 0) return parent;\n    var child;\n    var proto;\n\n    if (typeof parent != 'object') {\n      return parent;\n    }\n\n    if (util.isArray(parent)) {\n      child = [];\n    } else if (util.isRegExp(parent)) {\n      child = new RegExp(parent.source, util.getRegExpFlags(parent));\n      if (parent.lastIndex) child.lastIndex = parent.lastIndex;\n    } else if (util.isDate(parent)) {\n      child = new Date(parent.getTime());\n    } else if (useBuffer && Buffer.isBuffer(parent)) {\n      child = new Buffer(parent.length);\n      parent.copy(child);\n      return child;\n    } else {\n      if (typeof prototype == 'undefined') {\n        proto = Object.getPrototypeOf(parent);\n        child = Object.create(proto);\n      } else {\n        child = Object.create(prototype);\n        proto = prototype;\n      }\n    }\n\n    if (circular) {\n      var index = allParents.indexOf(parent);\n\n      if (index != -1) {\n        return allChildren[index];\n      }\n\n      allParents.push(parent);\n      allChildren.push(child);\n    }\n\n    for (var i in parent) {\n      var attrs;\n\n      if (proto) {\n        attrs = Object.getOwnPropertyDescriptor(proto, i);\n      }\n\n      if (attrs && attrs.set == null) {\n        continue;\n      }\n\n      child[i] = _clone(parent[i], depth - 1);\n    }\n\n    return child;\n  }\n\n  return _clone(parent, depth);\n}\n/**\n * Simple flat clone using prototype, accepts only objects, usefull for property\n * override on FLAT configuration object (no nested props).\n *\n * USE WITH CAUTION! This may not behave as you wish if you do not know how this\n * works.\n */\n\n\nclone.clonePrototype = function (parent) {\n  if (parent === null) return null;\n\n  var c = function () {};\n\n  c.prototype = parent;\n  return new c();\n};","map":{"version":3,"names":["objectToString","o","Object","prototype","toString","call","util","isArray","ar","Array","isDate","d","isRegExp","re","getRegExpFlags","flags","global","ignoreCase","multiline","module","exports","clone","parent","circular","depth","allParents","allChildren","useBuffer","Buffer","Infinity","_clone","child","proto","RegExp","source","lastIndex","Date","getTime","isBuffer","length","copy","getPrototypeOf","create","index","indexOf","push","i","attrs","getOwnPropertyDescriptor","set","clonePrototype","c"],"sources":["/Users/terwer/Documents/mydocs/my-note-docker/workspace/SiYuan/data/widgets/publisher/src/publisher/node_modules/clone/clone.js"],"sourcesContent":["'use strict';\n\nfunction objectToString(o) {\n  return Object.prototype.toString.call(o);\n}\n\n// shim for Node's 'util' package\n// DO NOT REMOVE THIS! It is required for compatibility with EnderJS (http://enderjs.com/).\nvar util = {\n  isArray: function (ar) {\n    return Array.isArray(ar) || (typeof ar === 'object' && objectToString(ar) === '[object Array]');\n  },\n  isDate: function (d) {\n    return typeof d === 'object' && objectToString(d) === '[object Date]';\n  },\n  isRegExp: function (re) {\n    return typeof re === 'object' && objectToString(re) === '[object RegExp]';\n  },\n  getRegExpFlags: function (re) {\n    var flags = '';\n    re.global && (flags += 'g');\n    re.ignoreCase && (flags += 'i');\n    re.multiline && (flags += 'm');\n    return flags;\n  }\n};\n\n\nif (typeof module === 'object')\n  module.exports = clone;\n\n/**\n * Clones (copies) an Object using deep copying.\n *\n * This function supports circular references by default, but if you are certain\n * there are no circular references in your object, you can save some CPU time\n * by calling clone(obj, false).\n *\n * Caution: if `circular` is false and `parent` contains circular references,\n * your program may enter an infinite loop and crash.\n *\n * @param `parent` - the object to be cloned\n * @param `circular` - set to true if the object to be cloned may contain\n *    circular references. (optional - true by default)\n * @param `depth` - set to a number if the object is only to be cloned to\n *    a particular depth. (optional - defaults to Infinity)\n * @param `prototype` - sets the prototype to be used when cloning an object.\n *    (optional - defaults to parent prototype).\n*/\n\nfunction clone(parent, circular, depth, prototype) {\n  // maintain two arrays for circular references, where corresponding parents\n  // and children have the same index\n  var allParents = [];\n  var allChildren = [];\n\n  var useBuffer = typeof Buffer != 'undefined';\n\n  if (typeof circular == 'undefined')\n    circular = true;\n\n  if (typeof depth == 'undefined')\n    depth = Infinity;\n\n  // recurse this function so we don't reset allParents and allChildren\n  function _clone(parent, depth) {\n    // cloning null always returns null\n    if (parent === null)\n      return null;\n\n    if (depth == 0)\n      return parent;\n\n    var child;\n    var proto;\n    if (typeof parent != 'object') {\n      return parent;\n    }\n\n    if (util.isArray(parent)) {\n      child = [];\n    } else if (util.isRegExp(parent)) {\n      child = new RegExp(parent.source, util.getRegExpFlags(parent));\n      if (parent.lastIndex) child.lastIndex = parent.lastIndex;\n    } else if (util.isDate(parent)) {\n      child = new Date(parent.getTime());\n    } else if (useBuffer && Buffer.isBuffer(parent)) {\n      child = new Buffer(parent.length);\n      parent.copy(child);\n      return child;\n    } else {\n      if (typeof prototype == 'undefined') {\n        proto = Object.getPrototypeOf(parent);\n        child = Object.create(proto);\n      }\n      else {\n        child = Object.create(prototype);\n        proto = prototype;\n      }\n    }\n\n    if (circular) {\n      var index = allParents.indexOf(parent);\n\n      if (index != -1) {\n        return allChildren[index];\n      }\n      allParents.push(parent);\n      allChildren.push(child);\n    }\n\n    for (var i in parent) {\n      var attrs;\n      if (proto) {\n        attrs = Object.getOwnPropertyDescriptor(proto, i);\n      }\n      \n      if (attrs && attrs.set == null) {\n        continue;\n      }\n      child[i] = _clone(parent[i], depth - 1);\n    }\n\n    return child;\n  }\n\n  return _clone(parent, depth);\n}\n\n/**\n * Simple flat clone using prototype, accepts only objects, usefull for property\n * override on FLAT configuration object (no nested props).\n *\n * USE WITH CAUTION! This may not behave as you wish if you do not know how this\n * works.\n */\nclone.clonePrototype = function(parent) {\n  if (parent === null)\n    return null;\n\n  var c = function () {};\n  c.prototype = parent;\n  return new c();\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}