{
	"ID": "20220715162032-hfvrtu4",
	"Spec": "1",
	"Type": "NodeDocument",
	"Properties": {
		"custom-desc": "消息中间件消息队列原理及activemqrocketmqrabbitmqkafka区别总结要点本文大概围绕如下几点进行阐述_为什么使用消息队列？使用消息队列有什么缺点?如何保证消息的顺序性？如何保证消息队列是高可用的？如何保证消息不被重复消费?如何保证消费的可靠性传输?消息队列如何选型?我们围绕以上七点进行阐述。只是提供一个思路而不是描述怎么调用消息队列的api。正文为什么要使用消息队列?分析_一个用消息队列的人不知道为啥用这就有点尴尬。没有复习这点很容易被问蒙然后就开始胡扯了。回答_这个问题咱只答三个最",
		"custom-doc-attrs": "[{\u0026amp;quot;name\u0026amp;quot;:\u0026amp;quot;updated\u0026amp;quot;,\u0026amp;quot;order\u0026amp;quot;:0,\u0026amp;quot;show\u0026amp;quot;:true}]",
		"custom-slug": "message-middleware-ncudb",
		"id": "20220715162032-hfvrtu4",
		"scroll": "{\u0026quot;startId\u0026quot;:\u0026quot;20220716232108-46szpet\u0026quot;,\u0026quot;endId\u0026quot;:\u0026quot;20220716014123-0qjdkyc\u0026quot;,\u0026quot;scrollTop\u0026quot;:0,\u0026quot;focusId\u0026quot;:\u0026quot;20220716232108-46szpet\u0026quot;,\u0026quot;focusStart\u0026quot;:0,\u0026quot;focusEnd\u0026quot;:0}",
		"tags": "消息,队列,消费,中间件,MQ",
		"title": "001.消息中间件",
		"updated": "20221023180326"
	},
	"Children": [
		{
			"ID": "20220716232108-46szpet",
			"Type": "NodeWidget",
			"Data": "\u003ciframe src=\"/widgets/Note Attrs\" data-src=\"/widgets/Note Attrs\" data-subtype=\"widget\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" style=\"height: 82px;\"\u003e\u003c/iframe\u003e",
			"Properties": {
				"id": "20220716232108-46szpet",
				"style": "text-align: left;",
				"updated": "20220716232108"
			}
		},
		{
			"ID": "20220805175749-zardqbf",
			"Type": "NodeWidget",
			"Data": "\u003ciframe src=\"/widgets/sy-post-publisher\" data-src=\"/widgets/sy-post-publisher\" data-subtype=\"widget\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\"\u003e\u003c/iframe\u003e",
			"Properties": {
				"id": "20220805175749-zardqbf",
				"style": "text-align: left;",
				"updated": "20220805175749"
			}
		},
		{
			"ID": "20220716014123-14t4kd6",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220716014123-14t4kd6",
				"updated": "20220716180019"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "消息队列原理及 ActiveMQ、RocketMQ、RabbitMQ、Kafka 区别总结"
				}
			]
		},
		{
			"ID": "20220716014123-iaxzi1u",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20220716014123-iaxzi1u",
				"updated": "20220716014123"
			},
			"Children": [
				{
					"Type": "NodeHeadingC8hMarker",
					"Data": "## ",
					"Properties": {
						"id": ""
					}
				},
				{
					"Type": "NodeText",
					"Data": "要点",
					"Properties": {
						"id": ""
					}
				}
			]
		},
		{
			"ID": "20220716014123-qts6es6",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220716014123-qts6es6",
				"updated": "20220716094300"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "本文大概围绕如下几点进行阐述:"
				}
			]
		},
		{
			"ID": "20220720042759-bejivu4",
			"Type": "NodeList",
			"ListData": {
				"Typ": 1
			},
			"Properties": {
				"id": "20220720042759-bejivu4",
				"updated": "20220720122821"
			},
			"Children": [
				{
					"ID": "20220720042759-q2m4t0t",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "MS4=",
						"Num": 1
					},
					"Properties": {
						"id": "20220720042759-q2m4t0t",
						"updated": "20220720122805"
					},
					"Children": [
						{
							"ID": "20220720042759-n982gpf",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20220720042759-n982gpf",
								"updated": "20220720122805"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "为什么使用消息队列？"
								}
							]
						}
					]
				},
				{
					"ID": "20220720042759-0oz77no",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "Mi4=",
						"Num": 2
					},
					"Properties": {
						"id": "20220720042759-0oz77no",
						"updated": "20220720122808"
					},
					"Children": [
						{
							"ID": "20220720042759-j69odkf",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20220720042759-j69odkf",
								"updated": "20220720122808"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "使用消息队列有什么缺点?"
								}
							]
						}
					]
				},
				{
					"ID": "20220720042759-qa2znth",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "My4=",
						"Num": 3
					},
					"Properties": {
						"id": "20220720042759-qa2znth",
						"updated": "20220720122811"
					},
					"Children": [
						{
							"ID": "20220720042759-9dk7fjv",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20220720042759-9dk7fjv",
								"updated": "20220720122811"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "如何保证消息的顺序性？"
								}
							]
						}
					]
				},
				{
					"ID": "20220720042759-f2m7egg",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "NC4=",
						"Num": 4
					},
					"Properties": {
						"id": "20220720042759-f2m7egg",
						"updated": "20220720122815"
					},
					"Children": [
						{
							"ID": "20220720042759-spyymkn",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20220720042759-spyymkn",
								"updated": "20220720122815"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "如何保证消息队列是高可用的？"
								}
							]
						}
					]
				},
				{
					"ID": "20220720042759-kacv3cc",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "NS4=",
						"Num": 5
					},
					"Properties": {
						"id": "20220720042759-kacv3cc",
						"updated": "20220720122817"
					},
					"Children": [
						{
							"ID": "20220720042759-lc3kbrc",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20220720042759-lc3kbrc",
								"updated": "20220720122817"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "如何保证消息不被重复消费?"
								}
							]
						}
					]
				},
				{
					"ID": "20220720042759-z5kbmfn",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "Ni4=",
						"Num": 6
					},
					"Properties": {
						"id": "20220720042759-z5kbmfn",
						"updated": "20220720122821"
					},
					"Children": [
						{
							"ID": "20220720042759-exp9nzm",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20220720042759-exp9nzm",
								"updated": "20220720122821"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "如何保证消费的可靠性传输?"
								}
							]
						}
					]
				},
				{
					"ID": "20220720042759-5m5ora3",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "Ny4=",
						"Num": 7
					},
					"Properties": {
						"id": "20220720042759-5m5ora3",
						"updated": "20220720122802"
					},
					"Children": [
						{
							"ID": "20220720042759-ingzdle",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20220720042759-ingzdle",
								"updated": "20220720122802"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "消息队列如何选型?"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20220716014123-3p2kvc9",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220716014123-3p2kvc9",
				"updated": "20220716094337"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "我们围绕以上七点进行阐述。只是提供一个思路，而不是描述怎么调用消息队列的 API。",
					"Properties": {
						"id": ""
					}
				}
			]
		},
		{
			"ID": "20220716014123-o4p6pq7",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20220716014123-o4p6pq7",
				"updated": "20220716014123"
			},
			"Children": [
				{
					"Type": "NodeHeadingC8hMarker",
					"Data": "## ",
					"Properties": {
						"id": ""
					}
				},
				{
					"Type": "NodeText",
					"Data": "正文",
					"Properties": {
						"id": ""
					}
				}
			]
		},
		{
			"ID": "20220716014123-y5aoyuz",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20220716014123-y5aoyuz",
				"updated": "20220716014123"
			},
			"Children": [
				{
					"Type": "NodeHeadingC8hMarker",
					"Data": "### ",
					"Properties": {
						"id": ""
					}
				},
				{
					"Type": "NodeText",
					"Data": "1、为什么要使用消息队列?",
					"Properties": {
						"id": ""
					}
				}
			]
		},
		{
			"ID": "20220716014123-65bm4uc",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220716014123-65bm4uc",
				"updated": "20220716094402"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "分析:一个用消息队列的人，不知道为啥用，这就有点尴尬。没有复习这点，很容易被问蒙，然后就开始胡扯了。",
					"Properties": {
						"id": ""
					}
				},
				{
					"Type": "NodeSoftBreak",
					"Data": "\n",
					"Properties": {
						"id": ""
					}
				},
				{
					"Type": "NodeText",
					"Data": "回答:这个问题,咱只答三个最主要的应用场景(不可否认还有其他的，但是只答三个主要的),即以下六个字:解耦、异步、削峰",
					"Properties": {
						"id": ""
					}
				}
			]
		},
		{
			"ID": "20220716014123-r2u7pu0",
			"Type": "NodeHeading",
			"HeadingLevel": 4,
			"Properties": {
				"id": "20220716014123-r2u7pu0",
				"updated": "20220716014123"
			},
			"Children": [
				{
					"Type": "NodeHeadingC8hMarker",
					"Data": "#### ",
					"Properties": {
						"id": ""
					}
				},
				{
					"Type": "NodeText",
					"Data": "(1)解耦",
					"Properties": {
						"id": ""
					}
				}
			]
		},
		{
			"ID": "20220716014123-8ftcra7",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220716014123-8ftcra7",
				"updated": "20220716094507"
			},
			"Children": [
				{
					"Type": "NodeTextMark",
					"Properties": {
						"id": ""
					},
					"TextMarkType": "strong",
					"TextMarkTextContent": "传统模式:"
				},
				{
					"Type": "NodeSoftBreak",
					"Data": "\n",
					"Properties": {
						"id": ""
					}
				},
				{
					"Type": "NodeText",
					"Data": "​",
					"Properties": {
						"id": ""
					}
				},
				{
					"Type": "NodeImage",
					"Properties": {
						"id": ""
					},
					"Children": [
						{
							"Type": "NodeBang",
							"Data": "!",
							"Properties": {
								"id": ""
							}
						},
						{
							"Type": "NodeOpenBracket",
							"Data": "[",
							"Properties": {
								"id": ""
							}
						},
						{
							"Type": "NodeLinkText",
							"Data": "img",
							"Properties": {
								"id": ""
							}
						},
						{
							"Type": "NodeCloseBracket",
							"Data": "]",
							"Properties": {
								"id": ""
							}
						},
						{
							"Type": "NodeOpenParen",
							"Data": "(",
							"Properties": {
								"id": ""
							}
						},
						{
							"Type": "NodeLinkDest",
							"Data": "https://img1.terwergreen.com/api/public/o_jieou5.png",
							"Properties": {
								"id": ""
							}
						},
						{
							"Type": "NodeCloseParen",
							"Data": ")",
							"Properties": {
								"id": ""
							}
						}
					]
				},
				{
					"Type": "NodeSoftBreak",
					"Data": "\n",
					"Properties": {
						"id": ""
					}
				},
				{
					"Type": "NodeText",
					"Data": "传统模式的缺点：",
					"Properties": {
						"id": ""
					}
				}
			]
		},
		{
			"ID": "20220716014123-2uc8jwu",
			"Type": "NodeList",
			"ListData": {
				"Tight": true,
				"BulletChar": 42,
				"Padding": 2,
				"Marker": "Kg==",
				"Num": -1
			},
			"Properties": {
				"id": "20220716014123-2uc8jwu",
				"updated": "20220716094502"
			},
			"Children": [
				{
					"ID": "20220716014123-bv55vh8",
					"Type": "NodeListItem",
					"Data": "*",
					"ListData": {
						"Tight": true,
						"BulletChar": 42,
						"Padding": 2,
						"Marker": "Kg==",
						"Num": -1
					},
					"Properties": {
						"id": "20220716014123-bv55vh8",
						"updated": "20220716094502"
					},
					"Children": [
						{
							"ID": "20220716014123-rxvgvsf",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20220716014123-rxvgvsf",
								"updated": "20220716094502"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "系统间耦合性太强，如上图所示，系统 A 在代码中直接调用系统 B 和系统 C 的代码，如果将来 D 系统接入，系统 A 还需要修改代码，过于麻烦！",
									"Properties": {
										"id": ""
									}
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20220716014123-sfgxpe2",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220716014123-sfgxpe2",
				"updated": "20220716014123"
			},
			"Children": [
				{
					"Type": "NodeTextMark",
					"Properties": {
						"id": ""
					},
					"TextMarkType": "strong",
					"TextMarkTextContent": "中间件模式:"
				},
				{
					"Type": "NodeSoftBreak",
					"Data": "\n",
					"Properties": {
						"id": ""
					}
				},
				{
					"Type": "NodeText",
					"Data": "​",
					"Properties": {
						"id": ""
					}
				},
				{
					"Type": "NodeImage",
					"Properties": {
						"id": ""
					},
					"Children": [
						{
							"Type": "NodeBang",
							"Data": "!",
							"Properties": {
								"id": ""
							}
						},
						{
							"Type": "NodeOpenBracket",
							"Data": "[",
							"Properties": {
								"id": ""
							}
						},
						{
							"Type": "NodeLinkText",
							"Data": "img",
							"Properties": {
								"id": ""
							}
						},
						{
							"Type": "NodeCloseBracket",
							"Data": "]",
							"Properties": {
								"id": ""
							}
						},
						{
							"Type": "NodeOpenParen",
							"Data": "(",
							"Properties": {
								"id": ""
							}
						},
						{
							"Type": "NodeLinkDest",
							"Data": "https://img1.terwergreen.com/api/public/o_jieou6.png",
							"Properties": {
								"id": ""
							}
						},
						{
							"Type": "NodeCloseParen",
							"Data": ")",
							"Properties": {
								"id": ""
							}
						}
					]
				},
				{
					"Type": "NodeSoftBreak",
					"Data": "\n",
					"Properties": {
						"id": ""
					}
				},
				{
					"Type": "NodeTextMark",
					"Properties": {
						"id": ""
					},
					"TextMarkType": "strong",
					"TextMarkTextContent": "中间件模式的的优点："
				}
			]
		},
		{
			"ID": "20220716014123-9u4vq6j",
			"Type": "NodeList",
			"ListData": {
				"Tight": true,
				"BulletChar": 42,
				"Padding": 2,
				"Marker": "Kg==",
				"Num": -1
			},
			"Properties": {
				"id": "20220716014123-9u4vq6j",
				"updated": "20220716094542"
			},
			"Children": [
				{
					"ID": "20220716014123-vwbae5c",
					"Type": "NodeListItem",
					"Data": "*",
					"ListData": {
						"Tight": true,
						"BulletChar": 42,
						"Padding": 2,
						"Marker": "Kg==",
						"Num": -1
					},
					"Properties": {
						"id": "20220716014123-vwbae5c",
						"updated": "20220716094542"
					},
					"Children": [
						{
							"ID": "20220716014123-xzei3n6",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20220716014123-xzei3n6",
								"updated": "20220716094542"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "将消息写入消息队列，需要消息的系统自己从消息队列中订阅，从而系统 A 不需要做任何修改。",
									"Properties": {
										"id": ""
									}
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20220716014123-fpct4ft",
			"Type": "NodeHeading",
			"HeadingLevel": 4,
			"Properties": {
				"id": "20220716014123-fpct4ft",
				"updated": "20220716014123"
			},
			"Children": [
				{
					"Type": "NodeHeadingC8hMarker",
					"Data": "#### ",
					"Properties": {
						"id": ""
					}
				},
				{
					"Type": "NodeText",
					"Data": "(2)异步",
					"Properties": {
						"id": ""
					}
				}
			]
		},
		{
			"ID": "20220716014123-en5dovv",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220716014123-en5dovv",
				"updated": "20220716094616"
			},
			"Children": [
				{
					"Type": "NodeTextMark",
					"Properties": {
						"id": ""
					},
					"TextMarkType": "strong",
					"TextMarkTextContent": "传统模式:"
				},
				{
					"Type": "NodeSoftBreak",
					"Data": "\n",
					"Properties": {
						"id": ""
					}
				},
				{
					"Type": "NodeText",
					"Data": "​",
					"Properties": {
						"id": ""
					}
				},
				{
					"Type": "NodeImage",
					"Properties": {
						"id": ""
					},
					"Children": [
						{
							"Type": "NodeBang",
							"Data": "!",
							"Properties": {
								"id": ""
							}
						},
						{
							"Type": "NodeOpenBracket",
							"Data": "[",
							"Properties": {
								"id": ""
							}
						},
						{
							"Type": "NodeLinkText",
							"Data": "img",
							"Properties": {
								"id": ""
							}
						},
						{
							"Type": "NodeCloseBracket",
							"Data": "]",
							"Properties": {
								"id": ""
							}
						},
						{
							"Type": "NodeOpenParen",
							"Data": "(",
							"Properties": {
								"id": ""
							}
						},
						{
							"Type": "NodeLinkDest",
							"Data": "https://img1.terwergreen.com/api/public/o_yibu2.png",
							"Properties": {
								"id": ""
							}
						},
						{
							"Type": "NodeCloseParen",
							"Data": ")",
							"Properties": {
								"id": ""
							}
						}
					]
				},
				{
					"Type": "NodeSoftBreak",
					"Data": "\n",
					"Properties": {
						"id": ""
					}
				},
				{
					"Type": "NodeText",
					"Data": "传统模式的缺点：",
					"Properties": {
						"id": ""
					}
				}
			]
		},
		{
			"ID": "20220716014123-d60f7mx",
			"Type": "NodeList",
			"ListData": {
				"Tight": true,
				"BulletChar": 42,
				"Padding": 2,
				"Marker": "Kg==",
				"Num": -1
			},
			"Properties": {
				"id": "20220716014123-d60f7mx",
				"updated": "20220716094627"
			},
			"Children": [
				{
					"ID": "20220716014123-6wkb686",
					"Type": "NodeListItem",
					"Data": "*",
					"ListData": {
						"Tight": true,
						"BulletChar": 42,
						"Padding": 2,
						"Marker": "Kg==",
						"Num": -1
					},
					"Properties": {
						"id": "20220716014123-6wkb686",
						"updated": "20220716094627"
					},
					"Children": [
						{
							"ID": "20220716014123-aun07vn",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20220716014123-aun07vn",
								"updated": "20220716094627"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "一些非必要的业务逻辑以同步的方式运行，太耗费时间。",
									"Properties": {
										"id": ""
									}
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20220716014123-d2gt1rr",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220716014123-d2gt1rr",
				"updated": "20220716094650"
			},
			"Children": [
				{
					"Type": "NodeTextMark",
					"Properties": {
						"id": ""
					},
					"TextMarkType": "strong",
					"TextMarkTextContent": "中间件模式:"
				},
				{
					"Type": "NodeSoftBreak",
					"Data": "\n",
					"Properties": {
						"id": ""
					}
				},
				{
					"Type": "NodeText",
					"Data": "​",
					"Properties": {
						"id": ""
					}
				},
				{
					"Type": "NodeImage",
					"Properties": {
						"id": ""
					},
					"Children": [
						{
							"Type": "NodeBang",
							"Data": "!",
							"Properties": {
								"id": ""
							}
						},
						{
							"Type": "NodeOpenBracket",
							"Data": "[",
							"Properties": {
								"id": ""
							}
						},
						{
							"Type": "NodeLinkText",
							"Data": "img",
							"Properties": {
								"id": ""
							}
						},
						{
							"Type": "NodeCloseBracket",
							"Data": "]",
							"Properties": {
								"id": ""
							}
						},
						{
							"Type": "NodeOpenParen",
							"Data": "(",
							"Properties": {
								"id": ""
							}
						},
						{
							"Type": "NodeLinkDest",
							"Data": "https://img1.terwergreen.com/api/public/o_yibu3.png",
							"Properties": {
								"id": ""
							}
						},
						{
							"Type": "NodeCloseParen",
							"Data": ")",
							"Properties": {
								"id": ""
							}
						}
					]
				},
				{
					"Type": "NodeSoftBreak",
					"Data": "\n",
					"Properties": {
						"id": ""
					}
				},
				{
					"Type": "NodeText",
					"Data": "中间件模式的的优点：",
					"Properties": {
						"id": ""
					}
				}
			]
		},
		{
			"ID": "20220716014123-uiyoa2o",
			"Type": "NodeList",
			"ListData": {
				"Tight": true,
				"BulletChar": 42,
				"Padding": 2,
				"Marker": "Kg==",
				"Num": -1
			},
			"Properties": {
				"id": "20220716014123-uiyoa2o",
				"updated": "20220716094647"
			},
			"Children": [
				{
					"ID": "20220716014123-qgcwftr",
					"Type": "NodeListItem",
					"Data": "*",
					"ListData": {
						"Tight": true,
						"BulletChar": 42,
						"Padding": 2,
						"Marker": "Kg==",
						"Num": -1
					},
					"Properties": {
						"id": "20220716014123-qgcwftr",
						"updated": "20220716094647"
					},
					"Children": [
						{
							"ID": "20220716014123-zbqi2ji",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20220716014123-zbqi2ji",
								"updated": "20220716094647"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "将消息写入消息队列，非必要的业务逻辑以异步的方式运行，加快响应速度",
									"Properties": {
										"id": ""
									}
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20220716014123-0qjdkyc",
			"Type": "NodeHeading",
			"HeadingLevel": 4,
			"Properties": {
				"id": "20220716014123-0qjdkyc",
				"updated": "20220716014123"
			},
			"Children": [
				{
					"Type": "NodeHeadingC8hMarker",
					"Data": "#### ",
					"Properties": {
						"id": ""
					}
				},
				{
					"Type": "NodeText",
					"Data": "(3)削峰",
					"Properties": {
						"id": ""
					}
				}
			]
		},
		{
			"ID": "20220716014123-v9p0yu1",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220716014123-v9p0yu1",
				"updated": "20220716014123"
			},
			"Children": [
				{
					"Type": "NodeTextMark",
					"Properties": {
						"id": ""
					},
					"TextMarkType": "strong",
					"TextMarkTextContent": "传统模式"
				},
				{
					"Type": "NodeSoftBreak",
					"Data": "\n",
					"Properties": {
						"id": ""
					}
				},
				{
					"Type": "NodeText",
					"Data": "​",
					"Properties": {
						"id": ""
					}
				},
				{
					"Type": "NodeImage",
					"Properties": {
						"id": ""
					},
					"Children": [
						{
							"Type": "NodeBang",
							"Data": "!",
							"Properties": {
								"id": ""
							}
						},
						{
							"Type": "NodeOpenBracket",
							"Data": "[",
							"Properties": {
								"id": ""
							}
						},
						{
							"Type": "NodeLinkText",
							"Data": "img",
							"Properties": {
								"id": ""
							}
						},
						{
							"Type": "NodeCloseBracket",
							"Data": "]",
							"Properties": {
								"id": ""
							}
						},
						{
							"Type": "NodeOpenParen",
							"Data": "(",
							"Properties": {
								"id": ""
							}
						},
						{
							"Type": "NodeLinkDest",
							"Data": "https://img1.terwergreen.com/api/public/o_xuefeng1.png",
							"Properties": {
								"id": ""
							}
						},
						{
							"Type": "NodeCloseParen",
							"Data": ")",
							"Properties": {
								"id": ""
							}
						}
					]
				},
				{
					"Type": "NodeSoftBreak",
					"Data": "\n",
					"Properties": {
						"id": ""
					}
				},
				{
					"Type": "NodeTextMark",
					"Properties": {
						"id": ""
					},
					"TextMarkType": "strong",
					"TextMarkTextContent": "传统模式的缺点："
				}
			]
		},
		{
			"ID": "20220716014123-a7hjdcl",
			"Type": "NodeList",
			"ListData": {
				"Tight": true,
				"BulletChar": 42,
				"Padding": 2,
				"Marker": "Kg==",
				"Num": -1
			},
			"Properties": {
				"id": "20220716014123-a7hjdcl",
				"updated": "20220716094701"
			},
			"Children": [
				{
					"ID": "20220716014123-8atsob1",
					"Type": "NodeListItem",
					"Data": "*",
					"ListData": {
						"Tight": true,
						"BulletChar": 42,
						"Padding": 2,
						"Marker": "Kg==",
						"Num": -1
					},
					"Properties": {
						"id": "20220716014123-8atsob1",
						"updated": "20220716094701"
					},
					"Children": [
						{
							"ID": "20220716014123-gnx90x6",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20220716014123-gnx90x6",
								"updated": "20220716094701"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "并发量大的时候，所有的请求直接怼到数据库，造成数据库连接异常",
									"Properties": {
										"id": ""
									}
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20220716014123-hz9y9tb",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220716014123-hz9y9tb",
				"updated": "20220716014123"
			},
			"Children": [
				{
					"Type": "NodeTextMark",
					"Properties": {
						"id": ""
					},
					"TextMarkType": "strong",
					"TextMarkTextContent": "中间件模式:"
				},
				{
					"Type": "NodeSoftBreak",
					"Data": "\n",
					"Properties": {
						"id": ""
					}
				},
				{
					"Type": "NodeText",
					"Data": "​",
					"Properties": {
						"id": ""
					}
				},
				{
					"Type": "NodeImage",
					"Properties": {
						"id": ""
					},
					"Children": [
						{
							"Type": "NodeBang",
							"Data": "!",
							"Properties": {
								"id": ""
							}
						},
						{
							"Type": "NodeOpenBracket",
							"Data": "[",
							"Properties": {
								"id": ""
							}
						},
						{
							"Type": "NodeLinkText",
							"Data": "img",
							"Properties": {
								"id": ""
							}
						},
						{
							"Type": "NodeCloseBracket",
							"Data": "]",
							"Properties": {
								"id": ""
							}
						},
						{
							"Type": "NodeOpenParen",
							"Data": "(",
							"Properties": {
								"id": ""
							}
						},
						{
							"Type": "NodeLinkDest",
							"Data": "https://img1.terwergreen.com/api/public/o_xuefeng2.png",
							"Properties": {
								"id": ""
							}
						},
						{
							"Type": "NodeCloseParen",
							"Data": ")",
							"Properties": {
								"id": ""
							}
						}
					]
				},
				{
					"Type": "NodeSoftBreak",
					"Data": "\n",
					"Properties": {
						"id": ""
					}
				},
				{
					"Type": "NodeTextMark",
					"Properties": {
						"id": ""
					},
					"TextMarkType": "strong",
					"TextMarkTextContent": "中间件模式的的优点："
				}
			]
		},
		{
			"ID": "20220716014123-2na6c43",
			"Type": "NodeList",
			"ListData": {
				"Tight": true,
				"BulletChar": 42,
				"Padding": 2,
				"Marker": "Kg==",
				"Num": -1
			},
			"Properties": {
				"id": "20220716014123-2na6c43",
				"updated": "20220716094708"
			},
			"Children": [
				{
					"ID": "20220716014123-sl0qmnx",
					"Type": "NodeListItem",
					"Data": "*",
					"ListData": {
						"Tight": true,
						"BulletChar": 42,
						"Padding": 2,
						"Marker": "Kg==",
						"Num": -1
					},
					"Properties": {
						"id": "20220716014123-sl0qmnx",
						"updated": "20220716094708"
					},
					"Children": [
						{
							"ID": "20220716014123-kmwx3qj",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20220716014123-kmwx3qj",
								"updated": "20220716094708"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "系统 A 慢慢的按照数据库能处理的并发量，从消息队列中慢慢拉取消息。在生产中，这个短暂的高峰期积压是允许的。",
									"Properties": {
										"id": ""
									}
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20220716014123-j4m8bj8",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20220716014123-j4m8bj8",
				"updated": "20220716014123"
			},
			"Children": [
				{
					"Type": "NodeHeadingC8hMarker",
					"Data": "### ",
					"Properties": {
						"id": ""
					}
				},
				{
					"Type": "NodeText",
					"Data": "2、使用了消息队列会有什么缺点?",
					"Properties": {
						"id": ""
					}
				}
			]
		},
		{
			"ID": "20220716014123-4x51xuw",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220716014123-4x51xuw",
				"updated": "20220716094729"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "分析:一个使用了 MQ 的项目，如果连这个问题都没有考虑过，就把 MQ 引进去了，那就给自己的项目带来了风险。我们引入一个技术，要对这个技术的弊端有充分的认识，才能做好预防。要记住，不要给公司挖坑！",
					"Properties": {
						"id": ""
					}
				},
				{
					"Type": "NodeSoftBreak",
					"Data": "\n",
					"Properties": {
						"id": ""
					}
				},
				{
					"Type": "NodeText",
					"Data": "回答:回答也很容易，从以下两个个角度来答",
					"Properties": {
						"id": ""
					}
				}
			]
		},
		{
			"ID": "20220716014123-m0qnbtl",
			"Type": "NodeList",
			"ListData": {
				"Tight": true,
				"BulletChar": 42,
				"Padding": 2,
				"Marker": "Kg==",
				"Num": -1
			},
			"Properties": {
				"id": "20220716014123-m0qnbtl",
				"updated": "20220716094755"
			},
			"Children": [
				{
					"ID": "20220716014123-apqd0lm",
					"Type": "NodeListItem",
					"Data": "*",
					"ListData": {
						"Tight": true,
						"BulletChar": 42,
						"Padding": 2,
						"Marker": "Kg==",
						"Num": -1
					},
					"Properties": {
						"id": "20220716014123-apqd0lm",
						"updated": "20220716094734"
					},
					"Children": [
						{
							"ID": "20220716014123-wny9ezc",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20220716014123-wny9ezc",
								"updated": "20220716094734"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "系统可用性降低:你想啊，本来其他系统只要运行好好的，那你的系统就是正常的。现在你非要加个消息队列进去，那消息队列挂了，你的系统不是呵呵了。因此，系统可用性降低",
									"Properties": {
										"id": ""
									}
								}
							]
						}
					]
				},
				{
					"ID": "20220716014123-jvanl5j",
					"Type": "NodeListItem",
					"Data": "*",
					"ListData": {
						"Tight": true,
						"BulletChar": 42,
						"Padding": 2,
						"Marker": "Kg==",
						"Num": -1
					},
					"Properties": {
						"id": "20220716014123-jvanl5j",
						"updated": "20220716094755"
					},
					"Children": [
						{
							"ID": "20220716014123-u8alytx",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20220716014123-u8alytx",
								"updated": "20220716094755"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "系统复杂性增加:要多考虑很多方面的问题，比如一致性问题、如何保证消息不被重复消费，如何保证保证消息可靠传输。因此，需要考虑的东西更多，系统复杂性增大。",
									"Properties": {
										"id": ""
									}
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20220716014123-1yl11ks",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220716014123-1yl11ks",
				"updated": "20220716094758"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "但是，我们该用还是要用的。"
				}
			]
		},
		{
			"ID": "20220716014123-btm92bi",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20220716014123-btm92bi",
				"updated": "20220716170828"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "3、如何保证消息的顺序性？"
				}
			]
		},
		{
			"ID": "20220716014123-4g2tjt3",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220716014123-4g2tjt3",
				"updated": "20220716103429"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "分析:其实并非所有的公司都有这种业务需求，但是还是对这个问题要有所复习。"
				}
			]
		},
		{
			"ID": "20220716103429-qaj7k4d",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220716103429-qaj7k4d",
				"updated": "20220716103433"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "回答:针对这个问题，通过某种算法，将需要保持先后顺序的消息放到同一个消息队列中(kafka 中就是 partition,rabbitMq 中就是 queue)。然后只用一个消费者去消费该队列。"
				}
			]
		},
		{
			"ID": "20220716103434-fwdg7qt",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220716103434-fwdg7qt",
				"updated": "20220716103500"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "有的人会问:那如果为了吞吐量，有多个消费者去消费怎么办？"
				}
			]
		},
		{
			"ID": "20220716103501-pptovv5",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220716103501-pptovv5",
				"updated": "20220716103501"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "这个问题，没有固定回答的套路。比如我们有一个微博的操作，发微博、写评论、删除微博，这三个异步操作。如果是这样一个业务场景，那只要重试就行。比如你一个消费者先执行了写评论的操作，但是这时候，微博都还没发，写评论一定是失败的，等一段时间。等另一个消费者，先执行写评论的操作后，再执行，就可以成功。"
				}
			]
		},
		{
			"ID": "20220716103440-5xw32a8",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220716103440-5xw32a8",
				"updated": "20220716103526"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "总之，针对这个问题，我的观点是"
				},
				{
					"Type": "NodeTextMark",
					"Properties": {
						"style": "color: var(--b3-font-color1);"
					},
					"TextMarkType": "strong",
					"TextMarkTextContent": "保证入队有序就行，出队以后的顺序交给消费者自己去保证，没有固定套路。"
				},
				{
					"Type": "NodeKramdownSpanIAL",
					"Data": "{: style=\"color: var(--b3-font-color1);\"}"
				}
			]
		},
		{
			"ID": "20220716014123-n3iv604",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20220716014123-n3iv604",
				"updated": "20220716014123"
			},
			"Children": [
				{
					"Type": "NodeHeadingC8hMarker",
					"Data": "### ",
					"Properties": {
						"id": ""
					}
				},
				{
					"Type": "NodeText",
					"Data": "4、如何保证消息队列是高可用的？",
					"Properties": {
						"id": ""
					}
				}
			]
		},
		{
			"ID": "20220716014123-tlh4ix4",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220716014123-tlh4ix4",
				"updated": "20220716101939"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "分析:在第二点说过了，引入消息队列后，系统的可用性下降。在生产中，没人使用单机模式的消息队列。因此，作为一个合格的程序员，应该对消息队列的高可用有很深刻的了解。如果面试的时候，面试官问，你们的消息中间件如何保证高可用的？你的回答只是表明自己只会订阅和发布消息，面试官就会怀疑你是不是只是自己搭着玩，压根没在生产用过。请做一个爱思考，会思考，懂思考的程序员。",
					"Properties": {
						"id": ""
					}
				},
				{
					"Type": "NodeSoftBreak",
					"Data": "\n",
					"Properties": {
						"id": ""
					}
				},
				{
					"Type": "NodeText",
					"Data": "回答:这问题，其实要对消息队列的集群模式要有深刻了解，才好回答。",
					"Properties": {
						"id": ""
					}
				},
				{
					"Type": "NodeSoftBreak",
					"Data": "\n",
					"Properties": {
						"id": ""
					}
				},
				{
					"Type": "NodeText",
					"Data": "以 RocketMQ 为例，他的集群就有",
					"Properties": {
						"id": ""
					}
				},
				{
					"Type": "NodeTextMark",
					"Properties": {
						"id": "",
						"style": "color: var(--b3-font-color1);"
					},
					"TextMarkType": "strong",
					"TextMarkTextContent": "多 master 模式"
				},
				{
					"Type": "NodeKramdownSpanIAL",
					"Data": "{: style=\"color: var(--b3-font-color1);\"}",
					"Properties": {
						"id": ""
					}
				},
				{
					"Type": "NodeText",
					"Data": "、",
					"Properties": {
						"id": ""
					}
				},
				{
					"Type": "NodeTextMark",
					"Properties": {
						"id": "",
						"style": "color: var(--b3-font-color6);"
					},
					"TextMarkType": "strong",
					"TextMarkTextContent": "多 master 多 slave 异步复制模式"
				},
				{
					"Type": "NodeKramdownSpanIAL",
					"Data": "{: style=\"color: var(--b3-font-color6);\"}",
					"Properties": {
						"id": ""
					}
				},
				{
					"Type": "NodeText",
					"Data": "、",
					"Properties": {
						"id": ""
					}
				},
				{
					"Type": "NodeTextMark",
					"Properties": {
						"id": "",
						"style": "color: var(--b3-font-color7);"
					},
					"TextMarkType": "strong",
					"TextMarkTextContent": "多 master 多 slave 同步双写模式"
				},
				{
					"Type": "NodeKramdownSpanIAL",
					"Data": "{: style=\"color: var(--b3-font-color7);\"}",
					"Properties": {
						"id": ""
					}
				},
				{
					"Type": "NodeText",
					"Data": "。",
					"Properties": {
						"id": ""
					}
				}
			]
		},
		{
			"ID": "20220716100117-jutsx5g",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220716100117-jutsx5g",
				"updated": "20220716100128"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "多 master 多 slave 模式部署架构图:",
					"Properties": {
						"id": ""
					}
				},
				{
					"Type": "NodeSoftBreak",
					"Data": "\n",
					"Properties": {
						"id": ""
					}
				},
				{
					"Type": "NodeText",
					"Data": "​",
					"Properties": {
						"id": ""
					}
				},
				{
					"Type": "NodeImage",
					"Properties": {
						"id": ""
					},
					"Children": [
						{
							"Type": "NodeBang",
							"Data": "!",
							"Properties": {
								"id": ""
							}
						},
						{
							"Type": "NodeOpenBracket",
							"Data": "[",
							"Properties": {
								"id": ""
							}
						},
						{
							"Type": "NodeLinkText",
							"Data": "image",
							"Properties": {
								"id": ""
							}
						},
						{
							"Type": "NodeCloseBracket",
							"Data": "]",
							"Properties": {
								"id": ""
							}
						},
						{
							"Type": "NodeOpenParen",
							"Data": "(",
							"Properties": {
								"id": ""
							}
						},
						{
							"Type": "NodeLinkDest",
							"Data": "https://img1.terwergreen.com/api/public/o_rocketcluster.png",
							"Properties": {
								"id": ""
							}
						},
						{
							"Type": "NodeCloseParen",
							"Data": ")",
							"Properties": {
								"id": ""
							}
						}
					]
				},
				{
					"Type": "NodeSoftBreak",
					"Data": "\n",
					"Properties": {
						"id": ""
					}
				},
				{
					"Type": "NodeText",
					"Data": "其实博主第一眼看到这个图，就觉得和 kafka 好像，只是 NameServer 集群，在 kafka 中是用 zookeeper 代替，都是用来保存和发现 master 和 slave 用的。通信过程如下:",
					"Properties": {
						"id": ""
					}
				},
				{
					"Type": "NodeSoftBreak",
					"Data": "\n",
					"Properties": {
						"id": ""
					}
				},
				{
					"Type": "NodeText",
					"Data": "Producer 与 NameServer 集群中的其中一个节点（随机选择）建立长连接，定期从 NameServer 获取 Topic 路由信息，并向提供 Topic 服务的 Broker Master 建立长连接，且定时向 Broker 发送心跳。Producer 只能将消息发送到 Broker master，但是 Consumer 则不一样，它同时和提供 Topic 服务的 Master 和 Slave 建立长连接，既可以从 Broker Master 订阅消息，也可以从 Broker Slave 订阅消息。",
					"Properties": {
						"id": ""
					}
				}
			]
		},
		{
			"ID": "20220716100124-xcczy4v",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220716100124-xcczy4v",
				"updated": "20220716102257"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "那么 kafka 呢,为了对比说明直接上 kafka 的拓补架构图",
					"Properties": {
						"id": ""
					}
				},
				{
					"Type": "NodeSoftBreak",
					"Data": "\n",
					"Properties": {
						"id": ""
					}
				},
				{
					"Type": "NodeText",
					"Data": "​",
					"Properties": {
						"id": ""
					}
				},
				{
					"Type": "NodeImage",
					"Properties": {
						"id": ""
					},
					"Children": [
						{
							"Type": "NodeBang",
							"Data": "!",
							"Properties": {
								"id": ""
							}
						},
						{
							"Type": "NodeOpenBracket",
							"Data": "[",
							"Properties": {
								"id": ""
							}
						},
						{
							"Type": "NodeLinkText",
							"Data": "image",
							"Properties": {
								"id": ""
							}
						},
						{
							"Type": "NodeCloseBracket",
							"Data": "]",
							"Properties": {
								"id": ""
							}
						},
						{
							"Type": "NodeOpenParen",
							"Data": "(",
							"Properties": {
								"id": ""
							}
						},
						{
							"Type": "NodeLinkDest",
							"Data": "https://img1.terwergreen.com/api/public/o_kafka.png",
							"Properties": {
								"id": ""
							}
						},
						{
							"Type": "NodeCloseParen",
							"Data": ")",
							"Properties": {
								"id": ""
							}
						}
					]
				},
				{
					"Type": "NodeSoftBreak",
					"Data": "\n",
					"Properties": {
						"id": ""
					}
				},
				{
					"Type": "NodeText",
					"Data": "如上图所示，一个典型的 Kafka 集群中包含若干 Producer（可以是 web 前端产生的 Page View，或者是服务器日志，系统 CPU、Memory 等），若干 broker（Kafka 支持水平扩展，一般 broker 数量越多，集群吞吐率越高)，若干 Consumer Group，以及一个 Zookeeper 集群。Kafka 通过 Zookeeper 管理集群配置，选举 leader，以及在 Consumer Group 发生变化时进行 rebalance。Producer 使用 push 模式将消息发布到 broker，Consumer 使用 pull 模式从 broker 订阅并消费消息。",
					"Properties": {
						"id": ""
					}
				},
				{
					"Type": "NodeSoftBreak",
					"Data": "\n",
					"Properties": {
						"id": ""
					}
				},
				{
					"Type": "NodeText",
					"Data": "至于 rabbitMQ,也有普通集群和镜像集群模式。",
					"Properties": {
						"id": ""
					}
				},
				{
					"Type": "NodeSoftBreak",
					"Data": "\n",
					"Properties": {
						"id": ""
					}
				},
				{
					"Type": "NodeText",
					"Data": "要求，在回答高可用的问题时，应该能逻辑清晰的画出自己的 MQ 集群架构或清晰的叙述出来。",
					"Properties": {
						"id": ""
					}
				}
			]
		},
		{
			"ID": "20220716014123-hj14jz4",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20220716014123-hj14jz4",
				"updated": "20220716014123"
			},
			"Children": [
				{
					"Type": "NodeHeadingC8hMarker",
					"Data": "### ",
					"Properties": {
						"id": ""
					}
				},
				{
					"Type": "NodeText",
					"Data": "5、如何保证消息不被重复消费？",
					"Properties": {
						"id": ""
					}
				}
			]
		},
		{
			"ID": "20220716100147-o1zmqiy",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220716100147-o1zmqiy",
				"updated": "20220716100147"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "分析:这个问题其实换一种问法就是，如何保证消息队列的幂等性?这个问题可以认为是消息队列领域的基本问题。换句话来说，是在考察你的设计能力，这个问题的回答可以根据具体的业务场景来答，没有固定的答案。",
					"Properties": {
						"id": ""
					}
				},
				{
					"Type": "NodeSoftBreak",
					"Data": "\n",
					"Properties": {
						"id": ""
					}
				},
				{
					"Type": "NodeText",
					"Data": "回答:先来说一下为什么会造成重复消费?",
					"Properties": {
						"id": ""
					}
				}
			]
		},
		{
			"ID": "20220716014123-bm304og",
			"Type": "NodeList",
			"ListData": {
				"Tight": true,
				"BulletChar": 42,
				"Padding": 2,
				"Marker": "Kg==",
				"Num": -1
			},
			"Properties": {
				"id": "20220716014123-bm304og",
				"updated": "20220716102425"
			},
			"Children": [
				{
					"ID": "20220716100147-zhr9q4p",
					"Type": "NodeListItem",
					"Data": "*",
					"ListData": {
						"Tight": true,
						"BulletChar": 42,
						"Padding": 2,
						"Marker": "Kg==",
						"Num": -1
					},
					"Properties": {
						"id": "20220716100147-zhr9q4p",
						"updated": "20220716100147"
					},
					"Children": [
						{
							"ID": "20220716100147-hetwsqx",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20220716100147-hetwsqx",
								"updated": "20220716100308"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "其实无论是那种消息队列，造成重复消费原因其实都是类似的。正常情况下，消费者在消费消息时候，消费完毕后，会发送一个确认信息给消息队列，消息队列就知道该消息被消费了，就会将该消息从消息队列中删除。只是不同的消息队列发送的确认信息形式不同,例如 RabbitMQ 是发送一个 ACK 确认消息，RocketMQ 是返回一个 CONSUME_SUCCESS 成功标志，kafka 实际上有个 offset 的概念，简单说一下(如果还不懂，出门找一个 kafka 入门到精通教程),就是每一个消息都有一个 offset，kafka 消费过消息后，需要提交 offset，让消息队列知道自己已经消费过了。那造成重复消费的原因?，就是因为网络传输等等故障，确认信息没有传送到消息队列，导致消息队列不知道自己已经消费过该消息了，再次将该消息分发给其他的消费者。",
									"Properties": {
										"id": ""
									}
								}
							]
						}
					]
				},
				{
					"ID": "20220716100156-ltr5fer",
					"Type": "NodeListItem",
					"Data": "*",
					"ListData": {
						"Tight": true,
						"BulletChar": 42,
						"Padding": 2,
						"Marker": "Kg==",
						"Num": -1
					},
					"Properties": {
						"id": "20220716100156-ltr5fer",
						"updated": "20220716100156"
					},
					"Children": [
						{
							"ID": "20220716100156-em97ek5",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20220716100156-em97ek5",
								"updated": "20220716100220"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "如何解决?这个问题针对业务场景来答分以下几点",
									"Properties": {
										"id": ""
									}
								}
							]
						}
					]
				},
				{
					"ID": "20220716100250-silcxp1",
					"Type": "NodeListItem",
					"Data": "*",
					"ListData": {
						"Tight": true,
						"BulletChar": 42,
						"Padding": 2,
						"Marker": "Kg==",
						"Num": -1
					},
					"Properties": {
						"id": "20220716100250-silcxp1",
						"updated": "20220716100250"
					},
					"Children": [
						{
							"ID": "20220716100250-ru6l3a1",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20220716100250-ru6l3a1",
								"updated": "20220716100321"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "(1)比如，你拿到这个消息做数据库的 insert 操作。那就容易了，给这个消息做一个唯一主键，那么就算出现重复消费的情况，就会导致主键冲突，避免数据库出现脏数据。",
									"Properties": {
										"id": ""
									}
								}
							]
						}
					]
				},
				{
					"ID": "20220716100332-k0xxl42",
					"Type": "NodeListItem",
					"Data": "*",
					"ListData": {
						"Tight": true,
						"BulletChar": 42,
						"Padding": 2,
						"Marker": "Kg==",
						"Num": -1
					},
					"Properties": {
						"id": "20220716100332-k0xxl42",
						"updated": "20220716102425"
					},
					"Children": [
						{
							"ID": "20220716100332-szr9mr9",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20220716100332-szr9mr9",
								"updated": "20220716102425"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "(2)再比如，你拿到这个消息做 redis 的 set 的操作，那就容易了，不用解决，因为你无论 set 几次结果都是一样的，set 操作本来就算幂等操作。",
									"Properties": {
										"id": ""
									}
								}
							]
						}
					]
				},
				{
					"ID": "20220716100337-zm7vejn",
					"Type": "NodeListItem",
					"Data": "*",
					"ListData": {
						"Tight": true,
						"BulletChar": 42,
						"Padding": 2,
						"Marker": "Kg==",
						"Num": -1
					},
					"Properties": {
						"id": "20220716100337-zm7vejn",
						"updated": "20220716100344"
					},
					"Children": [
						{
							"ID": "20220716100337-el5gq38",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20220716100337-el5gq38",
								"updated": "20220716100344"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "(3)如果上面两种情况还不行，上大招。准备一个第三方介质,来做消费记录。以 redis 为例，给消息分配一个全局 id，只要消费过该消息，将 \u003cid,message\u003e 以 K-V 形式写入 redis。那消费者开始消费前，先去 redis 中查询有没消费记录即可。",
									"Properties": {
										"id": ""
									}
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20220716014123-bg3f806",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20220716014123-bg3f806",
				"updated": "20220716014123"
			},
			"Children": [
				{
					"Type": "NodeHeadingC8hMarker",
					"Data": "### ",
					"Properties": {
						"id": ""
					}
				},
				{
					"Type": "NodeText",
					"Data": "6、如何保证消费的可靠性传输?",
					"Properties": {
						"id": ""
					}
				}
			]
		},
		{
			"ID": "20220716014123-httcukt",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220716014123-httcukt",
				"updated": "20220716100354"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "分析:我们在使用消息队列的过程中，应该做到消息不能多消费，也不能少消费。如果无法做到可靠性传输，可能给公司带来千万级别的财产损失。同样的，如果可靠性传输在使用过程中，没有考虑到，这不是给公司挖坑么，你可以拍拍屁股走了，公司损失的钱，谁承担。还是那句话，认真对待每一个项目，不要给公司挖坑。",
					"Properties": {
						"id": ""
					}
				},
				{
					"Type": "NodeSoftBreak",
					"Data": "\n",
					"Properties": {
						"id": ""
					}
				},
				{
					"Type": "NodeText",
					"Data": "回答:其实这个可靠性传输，每种 MQ 都要从三个角度来分析:生产者弄丢数据、消息队列弄丢数据、消费者弄丢数据",
					"Properties": {
						"id": ""
					}
				}
			]
		},
		{
			"ID": "20220716014123-ocehlwk",
			"Type": "NodeHeading",
			"HeadingLevel": 4,
			"Properties": {
				"id": "20220716014123-ocehlwk",
				"updated": "20220716014123"
			},
			"Children": [
				{
					"Type": "NodeHeadingC8hMarker",
					"Data": "#### ",
					"Properties": {
						"id": ""
					}
				},
				{
					"Type": "NodeText",
					"Data": "RabbitMQ",
					"Properties": {
						"id": ""
					}
				}
			]
		},
		{
			"ID": "20220716014123-szm26oq",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220716014123-szm26oq",
				"updated": "20220716103005"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "(1)生产者丢数据",
					"Properties": {
						"id": ""
					}
				}
			]
		},
		{
			"ID": "20220716103005-fp2cm4d",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220716103005-fp2cm4d",
				"updated": "20220716103043"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "从生产者弄丢数据这个角度来看，RabbitMQ 提供 transaction 和 confirm 模式来确保生产者不丢消息。",
					"Properties": {
						"id": ""
					}
				},
				{
					"Type": "NodeSoftBreak",
					"Data": "\n",
					"Properties": {
						"id": ""
					}
				},
				{
					"Type": "NodeText",
					"Data": "transaction 机制就是说，发送消息前，开启事物(channel.txSelect())，然后发送消息，如果发送过程中出现什么异常，事物就会回滚(channel.txRollback())，如果发送成功则提交事物(channel.txCommit())。",
					"Properties": {
						"id": ""
					}
				}
			]
		},
		{
			"ID": "20220716103046-74ap0bp",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220716103046-74ap0bp",
				"updated": "20220716103127"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "然而缺点就是吞吐量下降了，生产上用 confirm 模式的居多。一旦 channel 进入 confirm 模式，所有在该信道上面发布的消息都将会被指派一个唯一的 ID(从 1 开始)，一旦消息被投递到所有匹配的队列之后，rabbitMQ 就会发送一个 Ack 给生产者(包含消息的唯一 ID)，这就使得生产者知道消息已经正确到达目的队列了.如果 rabiitMQ 没能处理该消息，则会发送一个 Nack 消息给你，你可以进行重试操作。处理 Ack 和 Nack 的代码如下所示:",
					"Properties": {
						"id": ""
					}
				}
			]
		},
		{
			"ID": "20220716102553-ndidxdm",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"CodeBlockFenceChar": 96,
			"CodeBlockFenceLen": 3,
			"CodeBlockOpenFence": "YGBg",
			"CodeBlockInfo": "amF2YQ==",
			"CodeBlockCloseFence": "YGBg",
			"Properties": {
				"id": "20220716102553-ndidxdm",
				"updated": "20220716102945"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```",
					"CodeBlockFenceLen": 3,
					"Properties": {
						"id": ""
					}
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ==",
					"Properties": {
						"id": ""
					}
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "channel.addConfirmListener(new ConfirmListener() {\n    @Override\n    public void handleNack ( long deliveryTag, boolean multiple) throws IOException {\n        System.out.println(\"nack: deliveryTag = \" + deliveryTag + \" multiple: \" + multiple);\n    }\n    @Override**\n    public void handleAck ( long deliveryTag, boolean multiple) throws IOException {\n        System.out.println(\"ack: deliveryTag = \" + deliveryTag + \" multiple: \" + multiple);\n    }\n});\n",
					"Properties": {
						"id": ""
					}
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```",
					"CodeBlockFenceLen": 3,
					"Properties": {
						"id": ""
					}
				}
			]
		},
		{
			"ID": "20220716014123-uvky52w",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220716014123-uvky52w",
				"updated": "20220716103141"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "(2)消息队列丢数据",
					"Properties": {
						"id": ""
					}
				}
			]
		},
		{
			"ID": "20220716103141-yoyp75k",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220716103141-yoyp75k",
				"updated": "20220716103216"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "处理消息队列丢数据的情况，一般是开启持久化磁盘的配置。这个持久化配置可以和 confirm 机制配合使用，你可以在消息持久化磁盘后，再给生产者发送一个 Ack 信号。这样，如果消息持久化磁盘之前，RabbitMQ 阵亡了，那么生产者收不到 Ack 信号，生产者会自动重发。",
					"Properties": {
						"id": ""
					}
				},
				{
					"Type": "NodeSoftBreak",
					"Data": "\n",
					"Properties": {
						"id": ""
					}
				},
				{
					"Type": "NodeText",
					"Data": "那么如何持久化呢，这里顺便说一下吧，其实也很容易，就下面两步",
					"Properties": {
						"id": ""
					}
				}
			]
		},
		{
			"ID": "20220716103156-6e9vypy",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220716103156-6e9vypy",
				"updated": "20220716103228"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "1、将 queue 的持久化标识 durable 设置为 true,则代表是一个持久的队列",
					"Properties": {
						"id": ""
					}
				}
			]
		},
		{
			"ID": "20220716103229-xdgt6qc",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220716103229-xdgt6qc",
				"updated": "20220716103232"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "2、发送消息的时候将 deliveryMode=2",
					"Properties": {
						"id": ""
					}
				}
			]
		},
		{
			"ID": "20220716103233-pirushx",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220716103233-pirushx",
				"updated": "20220716103308"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "这样设置以后，RabbitMQ 就算挂了，重启后也能恢复数据",
					"Properties": {
						"id": ""
					}
				}
			]
		},
		{
			"ID": "20220716103236-z5wy2o9",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220716103236-z5wy2o9",
				"updated": "20220716103240"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "(3)消费者丢数据",
					"Properties": {
						"id": ""
					}
				}
			]
		},
		{
			"ID": "20220716103240-0rrd2b4",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220716103240-0rrd2b4",
				"updated": "20220716103312"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "消费者丢数据一般是因为采用了自动确认消息模式。这种模式下，消费者会自动确认收到信息。这时 RahbitMQ 会立即将消息删除，这种情况下如果消费者出现异常而没能处理该消息，就会丢失该消息。",
					"Properties": {
						"id": ""
					}
				}
			]
		},
		{
			"ID": "20220716103243-23zgonr",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220716103243-23zgonr",
				"updated": "20220716103243"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "至于解决方案，采用手动确认消息即可。",
					"Properties": {
						"id": ""
					}
				}
			]
		},
		{
			"ID": "20220716014123-ctekhvi",
			"Type": "NodeHeading",
			"HeadingLevel": 4,
			"Properties": {
				"id": "20220716014123-ctekhvi",
				"updated": "20220716014123"
			},
			"Children": [
				{
					"Type": "NodeHeadingC8hMarker",
					"Data": "#### ",
					"Properties": {
						"id": ""
					}
				},
				{
					"Type": "NodeText",
					"Data": "kafka",
					"Properties": {
						"id": ""
					}
				}
			]
		},
		{
			"ID": "20220716014123-33vuj7r",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220716014123-33vuj7r",
				"updated": "20220716103334"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "这里先引一张 kafka Replication 的数据流向图",
					"Properties": {
						"id": ""
					}
				},
				{
					"Type": "NodeSoftBreak",
					"Data": "\n",
					"Properties": {
						"id": ""
					}
				},
				{
					"Type": "NodeText",
					"Data": "​",
					"Properties": {
						"id": ""
					}
				},
				{
					"Type": "NodeImage",
					"Properties": {
						"id": ""
					},
					"Children": [
						{
							"Type": "NodeBang",
							"Data": "!",
							"Properties": {
								"id": ""
							}
						},
						{
							"Type": "NodeOpenBracket",
							"Data": "[",
							"Properties": {
								"id": ""
							}
						},
						{
							"Type": "NodeLinkText",
							"Data": "image",
							"Properties": {
								"id": ""
							}
						},
						{
							"Type": "NodeCloseBracket",
							"Data": "]",
							"Properties": {
								"id": ""
							}
						},
						{
							"Type": "NodeOpenParen",
							"Data": "(",
							"Properties": {
								"id": ""
							}
						},
						{
							"Type": "NodeLinkDest",
							"Data": "https://img1.terwergreen.com/api/public/o_kafka1png.png",
							"Properties": {
								"id": ""
							}
						},
						{
							"Type": "NodeCloseParen",
							"Data": ")",
							"Properties": {
								"id": ""
							}
						}
					]
				},
				{
					"Type": "NodeSoftBreak",
					"Data": "\n",
					"Properties": {
						"id": ""
					}
				},
				{
					"Type": "NodeText",
					"Data": "Producer 在发布消息到某个 Partition 时，先通过 ZooKeeper 找到该 Partition 的 Leader，然后无论该 Topic 的 Replication Factor 为多少（也即该 Partition 有多少个 Replica），Producer 只将该消息发送到该 Partition 的 Leader。Leader 会将该消息写入其本地 Log。每个 Follower 都从 Leader 中 pull 数据。",
					"Properties": {
						"id": ""
					}
				},
				{
					"Type": "NodeSoftBreak",
					"Data": "\n",
					"Properties": {
						"id": ""
					}
				},
				{
					"Type": "NodeText",
					"Data": "针对上述情况，得出如下分析",
					"Properties": {
						"id": ""
					}
				}
			]
		},
		{
			"ID": "20220716103334-aycqtrw",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220716103334-aycqtrw",
				"updated": "20220716103337"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "(1)生产者丢数据",
					"Properties": {
						"id": ""
					}
				}
			]
		},
		{
			"ID": "20220716103337-xwaezpw",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220716103337-xwaezpw",
				"updated": "20220716103337"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "在 kafka 生产中，基本都有一个 leader 和多个 follwer。follwer 会去同步 leader 的信息。因此，为了避免生产者丢数据，做如下两点配置",
					"Properties": {
						"id": ""
					}
				}
			]
		},
		{
			"ID": "20220716014123-m6iydlq",
			"Type": "NodeList",
			"ListData": {
				"Typ": 1,
				"Tight": true,
				"Start": 1,
				"Delimiter": 46,
				"Padding": 3,
				"Marker": "MQ==",
				"Num": 1
			},
			"Properties": {
				"id": "20220716014123-m6iydlq",
				"updated": "20220716100435"
			},
			"Children": [
				{
					"ID": "20220716014123-vd47t4a",
					"Type": "NodeListItem",
					"Data": "1",
					"ListData": {
						"Typ": 1,
						"Tight": true,
						"Start": 1,
						"Delimiter": 46,
						"Padding": 3,
						"Marker": "MQ==",
						"Num": 1
					},
					"Properties": {
						"id": "20220716014123-vd47t4a",
						"updated": "20220716100432"
					},
					"Children": [
						{
							"ID": "20220716014123-2lyo9ai",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20220716014123-2lyo9ai",
								"updated": "20220716100432"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "第一个配置要在 producer 端设置 acks=all。这个配置保证了，follwer 同步完成后，才认为消息发送成功。",
									"Properties": {
										"id": ""
									}
								}
							]
						}
					]
				},
				{
					"ID": "20220716014123-h9omscr",
					"Type": "NodeListItem",
					"Data": "2",
					"ListData": {
						"Typ": 1,
						"Tight": true,
						"Start": 2,
						"Delimiter": 46,
						"Padding": 3,
						"Marker": "Mg==",
						"Num": 2
					},
					"Properties": {
						"id": "20220716014123-h9omscr",
						"updated": "20220716100435"
					},
					"Children": [
						{
							"ID": "20220716014123-sx6mad5",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20220716014123-sx6mad5",
								"updated": "20220716100435"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "在 producer 端设置 retries=MAX，一旦写入失败，这无限重试",
									"Properties": {
										"id": ""
									}
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20220716014123-b7fg41d",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220716014123-b7fg41d",
				"updated": "20220716103341"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "(2)消息队列丢数据",
					"Properties": {
						"id": ""
					}
				}
			]
		},
		{
			"ID": "20220716103341-ocipnre",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220716103341-ocipnre",
				"updated": "20220716103341"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "针对消息队列丢数据的情况，无外乎就是，数据还没同步，leader 就挂了，这时 zookpeer 会将其他的 follwer 切换为 leader,那数据就丢失了。针对这种情况，应该做两个配置。",
					"Properties": {
						"id": ""
					}
				}
			]
		},
		{
			"ID": "20220716014123-j5820r4",
			"Type": "NodeList",
			"ListData": {
				"Typ": 1,
				"Tight": true,
				"Start": 1,
				"Delimiter": 46,
				"Padding": 3,
				"Marker": "MQ==",
				"Num": 1
			},
			"Properties": {
				"id": "20220716014123-j5820r4",
				"updated": "20220716100442"
			},
			"Children": [
				{
					"ID": "20220716014123-kfoq7vn",
					"Type": "NodeListItem",
					"Data": "1",
					"ListData": {
						"Typ": 1,
						"Tight": true,
						"Start": 1,
						"Delimiter": 46,
						"Padding": 3,
						"Marker": "MQ==",
						"Num": 1
					},
					"Properties": {
						"id": "20220716014123-kfoq7vn",
						"updated": "20220716100440"
					},
					"Children": [
						{
							"ID": "20220716014123-if80kb5",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20220716014123-if80kb5",
								"updated": "20220716100440"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "replication.factor 参数，这个值必须大于 1，即要求每个 partition 必须有至少 2 个副本",
									"Properties": {
										"id": ""
									}
								}
							]
						}
					]
				},
				{
					"ID": "20220716014123-7ivxmds",
					"Type": "NodeListItem",
					"Data": "2",
					"ListData": {
						"Typ": 1,
						"Tight": true,
						"Start": 2,
						"Delimiter": 46,
						"Padding": 3,
						"Marker": "Mg==",
						"Num": 2
					},
					"Properties": {
						"id": "20220716014123-7ivxmds",
						"updated": "20220716100442"
					},
					"Children": [
						{
							"ID": "20220716014123-nzt3bwl",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20220716014123-nzt3bwl",
								"updated": "20220716100442"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "min.insync.replicas 参数，这个值必须大于 1，这个是要求一个 leader 至少感知到有至少一个 follower 还跟自己保持联系",
									"Properties": {
										"id": ""
									}
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20220716014123-2amfe1h",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220716014123-2amfe1h",
				"updated": "20220716100451"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "这两个配置加上上面生产者的配置联合起来用，基本可确保 kafka 不丢数据",
					"Properties": {
						"id": ""
					}
				}
			]
		},
		{
			"ID": "20220716014123-0akm9kx",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220716014123-0akm9kx",
				"updated": "20220716103347"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "(3)消费者丢数据",
					"Properties": {
						"id": ""
					}
				}
			]
		},
		{
			"ID": "20220716103347-ek9t6i0",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220716103347-ek9t6i0",
				"updated": "20220716103354"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "这种情况一般是自动提交了 offset，然后你处理程序过程中挂了。kafka 以为你处理好了。再强调一次 offset 是干嘛的",
					"Properties": {
						"id": ""
					}
				}
			]
		},
		{
			"ID": "20220716103354-bht3hss",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220716103354-bht3hss",
				"updated": "20220716103358"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "offset：指的是 kafka 的 topic 中的每个消费组消费的下标。简单的来说就是一条消息对应一个 offset 下标，每次消费数据的时候如果提交 offset，那么下次消费就会从提交的 offset 加一那里开始消费。",
					"Properties": {
						"id": ""
					}
				}
			]
		},
		{
			"ID": "20220716103359-6yig78y",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220716103359-6yig78y",
				"updated": "20220716103402"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "比如一个 topic 中有 100 条数据，我消费了 50 条并且提交了，那么此时的 kafka 服务端记录提交的 offset 就是 49(offset 从 0 开始)，那么下次消费的时候 offset 就从 50 开始消费。",
					"Properties": {
						"id": ""
					}
				}
			]
		},
		{
			"ID": "20220716103402-3nv2186",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220716103402-3nv2186",
				"updated": "20220716103402"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "解决方案也很简单，改成手动提交即可。",
					"Properties": {
						"id": ""
					}
				}
			]
		},
		{
			"ID": "20220716014123-kis7gna",
			"Type": "NodeHeading",
			"HeadingLevel": 4,
			"Properties": {
				"id": "20220716014123-kis7gna",
				"updated": "20220716100503"
			},
			"Children": [
				{
					"Type": "NodeHeadingC8hMarker",
					"Data": "#### ",
					"Properties": {
						"id": ""
					}
				},
				{
					"Type": "NodeTextMark",
					"Properties": {
						"id": ""
					},
					"TextMarkType": "strong",
					"TextMarkTextContent": "ActiveMQ 和 RocketMQ"
				}
			]
		},
		{
			"ID": "20220716014123-abi06wt",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220716014123-abi06wt",
				"updated": "20220716103424"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "原理类似",
					"Properties": {
						"id": ""
					}
				}
			]
		},
		{
			"ID": "20220716014123-6byimjk",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20220716014123-6byimjk",
				"updated": "20220716170832"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "7、消息队列如何选型?"
				}
			]
		},
		{
			"ID": "20220716014123-h71s6f0",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220716014123-h71s6f0",
				"updated": "20220716095039"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "目前只接触过 ActiveMQ,RabbitMQ,RocketMQ,Kafka，对什么 ZeroMQ 等其他 MQ 没啥理解，因此只能基于这四种 MQ 给出回答。\n分析:既然在项目中用了 MQ，肯定事先要对业界流行的 MQ 进行调研，如果连每种 MQ 的优缺点都没了解清楚，就拍脑袋依据喜好，用了某种 MQ，还是给项目挖坑。如果面试官问:\"你为什么用这种 MQ？。\"你直接回答\"领导决定的。\"这种回答就很 LOW 了。还是那句话，不要给公司挖坑。\n回答:首先，咱先上 "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "a",
					"TextMarkAHref": "https://activemq.apache.org/",
					"TextMarkATitle": "ActiveMQ",
					"TextMarkTextContent": "ActiveMQ"
				},
				{
					"Type": "NodeText",
					"Data": " 的社区，看看该 MQ 的更新频率:"
				}
			]
		},
		{
			"ID": "20220716015222-rvbpcw0",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220716015222-rvbpcw0",
				"updated": "20220716095810"
			},
			"Children": [
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "Apache.NMS.ActiveMQ 2.0.0 Release"
				}
			]
		},
		{
			"ID": "20220716015222-n1q0z8m",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220716015222-n1q0z8m",
				"updated": "20220716015222"
			},
			"Children": [
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "Jul 7th, 2022"
				}
			]
		},
		{
			"ID": "20220716015222-zlie5gw",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220716015222-zlie5gw",
				"updated": "20220716015222"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "NMS 2.0 implementation and bug fixes."
				}
			]
		},
		{
			"ID": "20220716015222-8zbpfwf",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220716015222-8zbpfwf",
				"updated": "20220716015222"
			},
			"Children": [
				{
					"Type": "NodeTextMark",
					"TextMarkType": "a",
					"TextMarkAHref": "https://activemq.apache.org/components/nms/providers/activemq/downloads/apachenmsactivemq-v200",
					"TextMarkTextContent": "Read More"
				}
			]
		},
		{
			"ID": "20220716015222-fitt1io",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220716015222-fitt1io",
				"updated": "20220716095819"
			},
			"Children": [
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "ActiveMQ Artemis 2.23.1"
				}
			]
		},
		{
			"ID": "20220716015222-zvh2y9d",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220716015222-zvh2y9d",
				"updated": "20220716015222"
			},
			"Children": [
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "Jun 21st, 2022"
				}
			]
		},
		{
			"ID": "20220716015222-14mr2n3",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220716015222-14mr2n3",
				"updated": "20220716015222"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "Bug fixing, addressing ARTEMIS-3856"
				}
			]
		},
		{
			"ID": "20220716015222-9m44ouk",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220716015222-9m44ouk",
				"updated": "20220716015222"
			},
			"Children": [
				{
					"Type": "NodeTextMark",
					"TextMarkType": "a",
					"TextMarkAHref": "https://activemq.apache.org/components/artemis/download/",
					"TextMarkTextContent": "Read More"
				}
			]
		},
		{
			"ID": "20220716015222-lnvcn1z",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220716015222-lnvcn1z",
				"updated": "20220716095826"
			},
			"Children": [
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "ActiveMQ Artemis 2.23.0"
				}
			]
		},
		{
			"ID": "20220716015222-j7gsk69",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220716015222-j7gsk69",
				"updated": "20220716015222"
			},
			"Children": [
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "Jun 13th, 2022"
				}
			]
		},
		{
			"ID": "20220716015222-ld5l1jz",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220716015222-ld5l1jz",
				"updated": "20220716015222"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "Bug fixes and improvements"
				}
			]
		},
		{
			"ID": "20220716015222-bo8i1t2",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220716015222-bo8i1t2",
				"updated": "20220716015222"
			},
			"Children": [
				{
					"Type": "NodeTextMark",
					"TextMarkType": "a",
					"TextMarkAHref": "https://activemq.apache.org/components/artemis/download/",
					"TextMarkTextContent": "Read More"
				}
			]
		},
		{
			"ID": "20220716015222-q777f8c",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220716015222-q777f8c",
				"updated": "20220716095833"
			},
			"Children": [
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "Apache.NMS.API 1.8.1 Release"
				}
			]
		},
		{
			"ID": "20220716015222-uryltbn",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220716015222-uryltbn",
				"updated": "20220716015222"
			},
			"Children": [
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "May 29th, 2022"
				}
			]
		},
		{
			"ID": "20220716015222-8d0zksw",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220716015222-8d0zksw",
				"updated": "20220716015222"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "Maintenance release."
				}
			]
		},
		{
			"ID": "20220716095232-j8svmoy",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220716095232-j8svmoy",
				"updated": "20220716095236"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "..."
				}
			]
		},
		{
			"ID": "20220716014123-4dz3hzp",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220716014123-4dz3hzp",
				"updated": "20220716095914"
			},
			"Children": [
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "我们可以看出，ActiveMq 最近还是在更新，并且出现了两个主要版本。"
				}
			]
		},
		{
			"ID": "20220716095329-f5lrdlt",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220716095329-f5lrdlt",
				"updated": "20220716095453"
			},
			"Children": [
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "image-20220716095438366"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "https://img1.terwergreen.com/api/public/image-20220716095438366.png"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				}
			]
		},
		{
			"ID": "20220716095454-scd540l",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220716095454-scd540l",
				"updated": "20220716095647"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "再看看 "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "a",
					"TextMarkAHref": "https://www.rabbitmq.com/",
					"TextMarkATitle": "RabbitMQ",
					"TextMarkTextContent": "RabbitMQ"
				}
			]
		},
		{
			"ID": "20220716015629-7odbgma",
			"Type": "NodeList",
			"ListData": {
				"Typ": 1
			},
			"Properties": {
				"id": "20220716015629-7odbgma",
				"updated": "20220716015629"
			},
			"Children": [
				{
					"ID": "20220716015629-ak9d8v7",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "MS4=",
						"Num": 1
					},
					"Properties": {
						"id": "20220716015629-ak9d8v7",
						"updated": "20220716015629"
					},
					"Children": [
						{
							"ID": "20220716015629-s11z7wb",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20220716015629-s11z7wb",
								"updated": "20220716015629"
							},
							"Children": [
								{
									"Type": "NodeTextMark",
									"TextMarkType": "strong",
									"TextMarkTextContent": "11 Jul 2022"
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "a",
									"TextMarkAHref": "https://www.rabbitmq.com/news.html#2022-07-11T14:00:00+00:00",
									"TextMarkTextContent": "RabbitMQ 3.10.6"
								}
							]
						}
					]
				},
				{
					"ID": "20220716015629-1i7hscn",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "Mi4=",
						"Num": 2
					},
					"Properties": {
						"id": "20220716015629-1i7hscn",
						"updated": "20220716015629"
					},
					"Children": [
						{
							"ID": "20220716015629-vlbdqy4",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20220716015629-vlbdqy4",
								"updated": "20220716015629"
							},
							"Children": [
								{
									"Type": "NodeTextMark",
									"TextMarkType": "strong",
									"TextMarkTextContent": "11 Jul 2022"
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "a",
									"TextMarkAHref": "https://www.rabbitmq.com/news.html#2022-07-11T14:00:00+00:00",
									"TextMarkTextContent": "RabbitMQ 3.9.21"
								}
							]
						}
					]
				},
				{
					"ID": "20220716015629-9os5w2v",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "My4=",
						"Num": 3
					},
					"Properties": {
						"id": "20220716015629-9os5w2v",
						"updated": "20220716015629"
					},
					"Children": [
						{
							"ID": "20220716015629-sndiwz4",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20220716015629-sndiwz4",
								"updated": "20220716015629"
							},
							"Children": [
								{
									"Type": "NodeTextMark",
									"TextMarkType": "strong",
									"TextMarkTextContent": "11 Jul 2022"
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "a",
									"TextMarkAHref": "https://www.rabbitmq.com/news.html#2022-07-11T14:00:00+00:00",
									"TextMarkTextContent": "RabbitMQ 3.8.35"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20220716014123-fart52m",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220716014123-fart52m",
				"updated": "20220716100653"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "我们可以看出，RabbitMQ 版本发布比 ActiveMq 频繁很多。至于 RocketMQ 和 kafka 就不带大家看了，总之也比 ActiveMQ 活跃的多。详情，可自行查阅。\n再来一个性能对比表"
				}
			]
		},
		{
			"ID": "20220716014123-mrzbck8",
			"Type": "NodeTable",
			"TableAligns": [
				0,
				0,
				0,
				0,
				0
			],
			"Properties": {
				"colgroup": "width: 98px;|||width: 228px;|",
				"custom-f": "",
				"id": "20220716014123-mrzbck8",
				"style": "text-align: center;",
				"updated": "20220716101218"
			},
			"Children": [
				{
					"Type": "NodeTableHead",
					"Data": "thead",
					"Children": [
						{
							"Type": "NodeTableRow",
							"Data": "tr",
							"Children": [
								{
									"Type": "NodeTableCell",
									"Data": "th",
									"Children": [
										{
											"Type": "NodeText",
											"Data": "特性"
										}
									]
								},
								{
									"Type": "NodeTableCell",
									"Data": "th",
									"Children": [
										{
											"Type": "NodeTextMark",
											"TextMarkType": "strong",
											"TextMarkTextContent": "ActiveMQ"
										}
									]
								},
								{
									"Type": "NodeTableCell",
									"Data": "th",
									"Children": [
										{
											"Type": "NodeTextMark",
											"TextMarkType": "strong",
											"TextMarkTextContent": "RabbitMQ"
										}
									]
								},
								{
									"Type": "NodeTableCell",
									"Data": "th",
									"Children": [
										{
											"Type": "NodeTextMark",
											"TextMarkType": "strong",
											"TextMarkTextContent": "RocketMQ"
										}
									]
								},
								{
									"Type": "NodeTableCell",
									"Data": "th",
									"Children": [
										{
											"Type": "NodeTextMark",
											"TextMarkType": "strong",
											"TextMarkTextContent": "kafka"
										}
									]
								}
							]
						}
					]
				},
				{
					"Type": "NodeTableRow",
					"Data": "tr",
					"Children": [
						{
							"Type": "NodeTableCell",
							"Data": "td",
							"Children": [
								{
									"Type": "NodeText",
									"Data": "开发语言"
								}
							]
						},
						{
							"Type": "NodeTableCell",
							"Data": "td",
							"Children": [
								{
									"Type": "NodeText",
									"Data": "java"
								}
							]
						},
						{
							"Type": "NodeTableCell",
							"Data": "td",
							"Children": [
								{
									"Type": "NodeText",
									"Data": "erlang"
								}
							]
						},
						{
							"Type": "NodeTableCell",
							"Data": "td",
							"Children": [
								{
									"Type": "NodeText",
									"Data": "java"
								}
							]
						},
						{
							"Type": "NodeTableCell",
							"Data": "td",
							"Children": [
								{
									"Type": "NodeText",
									"Data": "scala"
								}
							]
						}
					]
				},
				{
					"Type": "NodeTableRow",
					"Data": "tr",
					"Children": [
						{
							"Type": "NodeTableCell",
							"Data": "td",
							"Children": [
								{
									"Type": "NodeText",
									"Data": "单机吞吐量"
								}
							]
						},
						{
							"Type": "NodeTableCell",
							"Data": "td",
							"Children": [
								{
									"Type": "NodeText",
									"Data": "万级"
								}
							]
						},
						{
							"Type": "NodeTableCell",
							"Data": "td",
							"Children": [
								{
									"Type": "NodeText",
									"Data": "万级"
								}
							]
						},
						{
							"Type": "NodeTableCell",
							"Data": "td",
							"Children": [
								{
									"Type": "NodeText",
									"Data": "10 万级"
								}
							]
						},
						{
							"Type": "NodeTableCell",
							"Data": "td",
							"Children": [
								{
									"Type": "NodeText",
									"Data": "10 万级"
								}
							]
						}
					]
				},
				{
					"Type": "NodeTableRow",
					"Data": "tr",
					"Children": [
						{
							"Type": "NodeTableCell",
							"Data": "td",
							"Children": [
								{
									"Type": "NodeText",
									"Data": "时效性"
								}
							]
						},
						{
							"Type": "NodeTableCell",
							"Data": "td",
							"Children": [
								{
									"Type": "NodeText",
									"Data": "ms 级"
								}
							]
						},
						{
							"Type": "NodeTableCell",
							"Data": "td",
							"Children": [
								{
									"Type": "NodeText",
									"Data": "us 级"
								}
							]
						},
						{
							"Type": "NodeTableCell",
							"Data": "td",
							"Children": [
								{
									"Type": "NodeText",
									"Data": "ms 级"
								}
							]
						},
						{
							"Type": "NodeTableCell",
							"Data": "td",
							"Children": [
								{
									"Type": "NodeText",
									"Data": "ms 级以内"
								}
							]
						}
					]
				},
				{
					"Type": "NodeTableRow",
					"Data": "tr",
					"Children": [
						{
							"Type": "NodeTableCell",
							"Data": "td",
							"Children": [
								{
									"Type": "NodeText",
									"Data": "可用性"
								}
							]
						},
						{
							"Type": "NodeTableCell",
							"Data": "td",
							"Children": [
								{
									"Type": "NodeText",
									"Data": "高(主从架构)"
								}
							]
						},
						{
							"Type": "NodeTableCell",
							"Data": "td",
							"Children": [
								{
									"Type": "NodeText",
									"Data": "高(主从架构)"
								}
							]
						},
						{
							"Type": "NodeTableCell",
							"Data": "td",
							"Children": [
								{
									"Type": "NodeText",
									"Data": "非常高(分布式架构)"
								}
							]
						},
						{
							"Type": "NodeTableCell",
							"Data": "td",
							"Children": [
								{
									"Type": "NodeText",
									"Data": "非常高(分布式架构)"
								}
							]
						}
					]
				},
				{
					"Type": "NodeTableRow",
					"Data": "tr",
					"Children": [
						{
							"Type": "NodeTableCell",
							"Data": "td",
							"Children": [
								{
									"Type": "NodeText",
									"Data": "功能特性"
								}
							]
						},
						{
							"Type": "NodeTableCell",
							"Data": "td",
							"Children": [
								{
									"Type": "NodeTextMark",
									"TextMarkType": "strong",
									"TextMarkTextContent": "Apache 的"
								},
								{
									"Type": "NodeText",
									"Data": "，成熟的产品，在很多公司得到应用；有较多的文档；各种协议支持较好"
								}
							]
						},
						{
							"Type": "NodeTableCell",
							"Data": "td",
							"Children": [
								{
									"Type": "NodeTextMark",
									"TextMarkType": "strong",
									"TextMarkTextContent": "VMWare 的"
								},
								{
									"Type": "NodeText",
									"Data": "，基于 erlang 开发，所以并发能力很强，性能极其好，延时很低;管理界面较丰富"
								}
							]
						},
						{
							"Type": "NodeTableCell",
							"Data": "td",
							"Children": [
								{
									"Type": "NodeTextMark",
									"TextMarkType": "strong",
									"TextMarkTextContent": "Alibaba 的，已经捐献给 Apache"
								},
								{
									"Type": "NodeText",
									"Data": "，MQ 功能比较完备，扩展性佳"
								}
							]
						},
						{
							"Type": "NodeTableCell",
							"Data": "td",
							"Children": [
								{
									"Type": "NodeTextMark",
									"TextMarkType": "strong",
									"TextMarkTextContent": "Apache 的"
								},
								{
									"Type": "NodeText",
									"Data": "，只支持主要的 MQ 功能，像一些消息查询，消息回溯等功能没有提供，毕竟是为大数据准备的，在大数据领域应用广。"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20220716014123-dg2ftbl",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220716014123-dg2ftbl",
				"updated": "20220716095941"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "综合上面的材料得出以下两点:"
				}
			]
		},
		{
			"ID": "20220716095941-nj5wktt",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220716095941-nj5wktt",
				"updated": "20220716101536"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "(1)中小型软件公司，建议选 "
				},
				{
					"Type": "NodeTextMark",
					"Properties": {
						"style": "color: var(--b3-font-color4);"
					},
					"TextMarkType": "strong",
					"TextMarkTextContent": "RabbitMQ"
				},
				{
					"Type": "NodeKramdownSpanIAL",
					"Data": "{: style=\"color: var(--b3-font-color4);\"}"
				},
				{
					"Type": "NodeText",
					"Data": " 或者 "
				},
				{
					"Type": "NodeTextMark",
					"Properties": {
						"style": "color: var(--b3-font-color4);"
					},
					"TextMarkType": "strong",
					"TextMarkTextContent": "RocketMQ"
				},
				{
					"Type": "NodeKramdownSpanIAL",
					"Data": "{: style=\"color: var(--b3-font-color4);\"}"
				},
				{
					"Type": "NodeText",
					"Data": "。"
				}
			]
		},
		{
			"ID": "20220716101352-el9uouy",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220716101352-el9uouy",
				"updated": "20220716101352"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "一方面，erlang 语言天生具备高并发的特性，而且他的管理界面用起来十分方便。正所谓，成也萧何，败也萧何！他的弊端也在这里，虽然 RabbitMQ 是开源的，然而国内有几个能定制化开发 erlang 的程序员呢？所幸，RabbitMQ 的社区十分活跃，可以解决开发过程中遇到的 bug，这点对于中小型公司来说十分重要。"
				}
			]
		},
		{
			"ID": "20220716101403-psnhhw3",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220716101403-psnhhw3",
				"updated": "20220716101632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "不考虑 RocketMQ 和 kafka 的原因是，一方面中小型软件公司不如互联网公司，数据量没那么大，选消息中间件，应首选功能比较完备的，所以 kafka 排除。"
				}
			]
		},
		{
			"ID": "20220716101407-d2q8dna",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220716101407-d2q8dna",
				"updated": "20220716101659"
			},
			"Children": [
				{
					"Type": "NodeTextMark",
					"TextMarkType": "s",
					"TextMarkTextContent": "不考虑 RocketMQ 的原因是，RocketMQ 是阿里出品，如果阿里放弃维护 RocketMQ，中小型公司一般抽不出人来进行 RocketMQ 的定制化开发，因此不推荐，"
				},
				{
					"Type": "NodeTextMark",
					"Properties": {
						"style": "color: var(--b3-font-color1);"
					},
					"TextMarkType": "strong",
					"TextMarkTextContent": "目前已经捐献给 Apache，此项不成立。"
				},
				{
					"Type": "NodeKramdownSpanIAL",
					"Data": "{: style=\"color: var(--b3-font-color1);\"}"
				}
			]
		},
		{
			"ID": "20220716095934-1im7vxv",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220716095934-1im7vxv",
				"updated": "20220716101726"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "(2)大型软件公司，根据具体使用在 "
				},
				{
					"Type": "NodeTextMark",
					"Properties": {
						"style": "color: var(--b3-font-color6);"
					},
					"TextMarkType": "strong",
					"TextMarkTextContent": "RocketMQ"
				},
				{
					"Type": "NodeKramdownSpanIAL",
					"Data": "{: style=\"color: var(--b3-font-color6);\"}"
				},
				{
					"Type": "NodeText",
					"Data": " 和 "
				},
				{
					"Type": "NodeTextMark",
					"Properties": {
						"style": "color: var(--b3-font-color6);"
					},
					"TextMarkType": "strong",
					"TextMarkTextContent": "kafka"
				},
				{
					"Type": "NodeKramdownSpanIAL",
					"Data": "{: style=\"color: var(--b3-font-color6);\"}"
				},
				{
					"Type": "NodeText",
					"Data": " 之间二选一。一方面，大型软件公司，具备足够的资金搭建分布式环境，也具备足够大的数据量。针对 RocketMQ,大型软件公司也可以抽出人手对 RocketMQ 进行定制化开发，毕竟国内有能力改 JAVA 源码的人，还是相当多的。至于 kafka，根据业务场景选择，如果有日志采集功能，肯定是首选 kafka 了。具体该选哪个，看使用场景。"
				}
			]
		}
	]
}