{
	"ID": "20221010215316-2gah9xk",
	"Spec": "1",
	"Type": "NodeDocument",
	"Properties": {
		"custom-desc": "注意_方法的返回值对重载没有任何影响。类是一种抽象的概念对象是类的一种具体表示形式是具体的概念。先有类然后由类来生成对象（object）。对象又叫做实例（instance）。类由两大部分构成_属性以及方法。属性一般用名词来表示方法一般用动词来表示。如果一个java源文件中定义了多个类那么这些类中最多只能有一个类是public的换句话说定义的多个类可以都不是public的。在java中进行方法的参数传递时无论传递的是原生数据类型还是引用类型参数传递方式统一是传值（passbyvalue）。java中没有传引",
		"custom-slug": "java-object-oriented-advanced",
		"custom-vuepress-slug": "docs/001.后端开发/001.JavaSE/012.Java_SE_Lesson_1_面向对象高级.md",
		"custom-wordpress-post-id": "4302",
		"id": "20221010215316-2gah9xk",
		"scroll": "{\u0026amp;quot;startId\u0026amp;quot;:\u0026amp;quot;20221010215316-riumixu\u0026amp;quot;,\u0026amp;quot;endId\u0026amp;quot;:\u0026amp;quot;20221010220335-an1otiw\u0026amp;quot;,\u0026amp;quot;scrollTop\u0026amp;quot;:0,\u0026amp;quot;focusId\u0026amp;quot;:\u0026amp;quot;20221010220223-smt8j6m\u0026amp;quot;,\u0026amp;quot;focusStart\u0026amp;quot;:0,\u0026amp;quot;focusEnd\u0026amp;quot;:0}",
		"tags": "方法,子类,构造方法,对象,参数,面向对象,高级,senior",
		"title": "012.Java_SE_Lesson_1：面向对象高级",
		"updated": "20221010220359"
	},
	"Children": [
		{
			"ID": "20221010215316-riumixu",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221010215316-riumixu",
				"updated": "20221010220223"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "注意：方法的返回值对重载没有任何影响。",
					"Properties": {
						"id": ""
					}
				}
			]
		},
		{
			"ID": "20221010220223-kb1wq12",
			"Type": "NodeList",
			"ListData": {
				"Typ": 1,
				"Start": 1,
				"Delimiter": 46,
				"Padding": 3,
				"Marker": "MQ==",
				"Num": 1
			},
			"Properties": {
				"id": "20221010220223-kb1wq12",
				"updated": "20221010220223"
			},
			"Children": [
				{
					"ID": "20221010220223-ge79zfx",
					"Type": "NodeListItem",
					"Data": "1",
					"ListData": {
						"Typ": 1,
						"Start": 1,
						"Delimiter": 46,
						"Padding": 3,
						"Marker": "MQ==",
						"Num": 1
					},
					"Properties": {
						"id": "20221010220223-ge79zfx",
						"updated": "20221010220223"
					},
					"Children": [
						{
							"ID": "20221010220223-lbce73u",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221010220223-lbce73u",
								"updated": "20221010220223"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "类是一种抽象的概念，对象是类的一种具体表示形式，是具体的概念。先有类，然后由类来生成对象（Object）。对象又叫做实例（Instance）。",
									"Properties": {
										"id": ""
									}
								}
							]
						}
					]
				},
				{
					"ID": "20221010220223-1z4csnk",
					"Type": "NodeListItem",
					"Data": "2",
					"ListData": {
						"Typ": 1,
						"Tight": true,
						"Start": 2,
						"Delimiter": 46,
						"Padding": 3,
						"Marker": "Mg==",
						"Num": 2
					},
					"Properties": {
						"id": "20221010220223-1z4csnk",
						"updated": "20221010220223"
					},
					"Children": [
						{
							"ID": "20221010220223-4nidz0c",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221010220223-4nidz0c",
								"updated": "20221010220223"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "类由两大部分构成：属性以及方法。属性一般用名词来表示， 方法一般用动词来表示。",
									"Properties": {
										"id": ""
									}
								}
							]
						}
					]
				},
				{
					"ID": "20221010220223-vc9plmr",
					"Type": "NodeListItem",
					"Data": "3",
					"ListData": {
						"Typ": 1,
						"Tight": true,
						"Start": 3,
						"Delimiter": 46,
						"Padding": 3,
						"Marker": "Mw==",
						"Num": 3
					},
					"Properties": {
						"id": "20221010220223-vc9plmr",
						"updated": "20221010220223"
					},
					"Children": [
						{
							"ID": "20221010220223-af2n5bj",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221010220223-af2n5bj",
								"updated": "20221010220223"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "如果一个 java 源文件中定义了多个类，那么这些类中最多只能有一个类是 public 的，换句话说，定义的多个类可以都不是 public  的。",
									"Properties": {
										"id": ""
									}
								}
							]
						}
					]
				},
				{
					"ID": "20221010220223-f3f85fl",
					"Type": "NodeListItem",
					"Data": "4",
					"ListData": {
						"Typ": 1,
						"Tight": true,
						"Start": 4,
						"Delimiter": 46,
						"Padding": 3,
						"Marker": "NA==",
						"Num": 4
					},
					"Properties": {
						"id": "20221010220223-f3f85fl",
						"updated": "20221010220223"
					},
					"Children": [
						{
							"ID": "20221010220223-8kzmhwu",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221010220223-8kzmhwu",
								"updated": "20221010220223"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "在 Java 中进行方法的参数传递时，无论传递的是原生数据类型还是引用类型，参数传递方式统一是传值（pass by value）。 Java 中没有传引用（pass by reference）的概念。",
									"Properties": {
										"id": ""
									}
								}
							]
						}
					]
				},
				{
					"ID": "20221010220223-ohpzpdl",
					"Type": "NodeListItem",
					"Data": "5",
					"ListData": {
						"Typ": 1,
						"Tight": true,
						"Start": 5,
						"Delimiter": 46,
						"Padding": 3,
						"Marker": "NQ==",
						"Num": 5
					},
					"Properties": {
						"id": "20221010220223-ohpzpdl",
						"updated": "20221010220223"
					},
					"Children": [
						{
							"ID": "20221010220223-uo6ipsn",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221010220223-uo6ipsn",
								"updated": "20221010220223"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "方法重载（Overload）。",
									"Properties": {
										"id": ""
									}
								}
							]
						},
						{
							"ID": "20221010220223-7prkbk0",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221010220223-7prkbk0",
								"updated": "20221010220223"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "表示两个或多个方法名字相同，但方法参数不同。",
									"Properties": {
										"id": ""
									}
								}
							]
						},
						{
							"ID": "20221010220223-bv9z1k8",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221010220223-bv9z1k8",
								"updated": "20221010220223"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "方法参数不同有两层含义：",
									"Properties": {
										"id": ""
									}
								}
							]
						},
						{
							"ID": "20221010220223-pby2vqf",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221010220223-pby2vqf",
								"updated": "20221010220223"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "1）参数个数不同。",
									"Properties": {
										"id": ""
									}
								}
							]
						},
						{
							"ID": "20221010220223-79a9rz3",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221010220223-79a9rz3",
								"updated": "20221010220223"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "2）参数类型不同。",
									"Properties": {
										"id": ""
									}
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20221010220223-mqby3h5",
			"Type": "NodeList",
			"ListData": {
				"Typ": 1,
				"Start": 6,
				"Delimiter": 46,
				"Padding": 3,
				"Marker": "Ng==",
				"Num": 6
			},
			"Properties": {
				"id": "20221010220223-mqby3h5",
				"updated": "20221010220223"
			},
			"Children": [
				{
					"ID": "20221010220223-zc6m416",
					"Type": "NodeListItem",
					"Data": "6",
					"ListData": {
						"Typ": 1,
						"Start": 6,
						"Delimiter": 46,
						"Padding": 3,
						"Marker": "Ng==",
						"Num": 6
					},
					"Properties": {
						"id": "20221010220223-zc6m416",
						"updated": "20221010220223"
					},
					"Children": [
						{
							"ID": "20221010220223-pzfzvdy",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221010220223-pzfzvdy",
								"updated": "20221010220223"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "构造方法重载：只需看参数即可。如果想在一个构造方法中调用另外一个构造方法，那么可以使用 this 的方式调用，this 括号中的参数表示目标构造方法的参数。this 必须要作为构造方法的第一条语句，换句话说，this 之前不能有任何可执行的代码。",
									"Properties": {
										"id": ""
									}
								}
							]
						}
					]
				},
				{
					"ID": "20221010220223-bgiuy06",
					"Type": "NodeListItem",
					"Data": "7",
					"ListData": {
						"Typ": 1,
						"Tight": true,
						"Start": 7,
						"Delimiter": 46,
						"Padding": 3,
						"Marker": "Nw==",
						"Num": 7
					},
					"Properties": {
						"id": "20221010220223-bgiuy06",
						"updated": "20221010220223"
					},
					"Children": [
						{
							"ID": "20221010220223-n7sial1",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221010220223-n7sial1",
								"updated": "20221010220223"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "继承（Inheritence）：Java 是单继承的，意味着一个类只能从",
									"Properties": {
										"id": ""
									}
								}
							]
						},
						{
							"ID": "20221010220223-xzut6d7",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221010220223-xzut6d7",
								"updated": "20221010220223"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "另一个类继承（被继承的类叫做父类【基类，base class】， 继承的类叫做子类），Java 中的继承使用 extends 关键字。",
									"Properties": {
										"id": ""
									}
								}
							]
						}
					]
				},
				{
					"ID": "20221010220223-zgxvbpm",
					"Type": "NodeListItem",
					"Data": "8",
					"ListData": {
						"Typ": 1,
						"Tight": true,
						"Start": 8,
						"Delimiter": 46,
						"Padding": 3,
						"Marker": "OA==",
						"Num": 8
					},
					"Properties": {
						"id": "20221010220223-zgxvbpm",
						"updated": "20221010220223"
					},
					"Children": [
						{
							"ID": "20221010220223-d2pykl5",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221010220223-d2pykl5",
								"updated": "20221010220223"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "当生成子类对象时，Java 默认首先调用父类的不带参数的构造方法，然后执行该构造方法，生成父类的对象。接下来，再去调用子类的构造方法，生成子类的对象。【要想生成子类的对象，首先需要生成父类的对象，没有父类对象就没有子类对象。比如说：没有父亲，就没有孩子】。",
									"Properties": {
										"id": ""
									}
								}
							]
						}
					]
				},
				{
					"ID": "20221010220223-q8d09k9",
					"Type": "NodeListItem",
					"Data": "9",
					"ListData": {
						"Typ": 1,
						"Tight": true,
						"Start": 9,
						"Delimiter": 46,
						"Padding": 3,
						"Marker": "OQ==",
						"Num": 9
					},
					"Properties": {
						"id": "20221010220223-q8d09k9",
						"updated": "20221010220223"
					},
					"Children": [
						{
							"ID": "20221010220223-886q7yo",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221010220223-886q7yo",
								"updated": "20221010220223"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "super 关键字：super 表示对父类对象的引用。",
									"Properties": {
										"id": ""
									}
								}
							]
						}
					]
				},
				{
					"ID": "20221010220223-qo8svk4",
					"Type": "NodeListItem",
					"Data": "10",
					"ListData": {
						"Typ": 1,
						"Tight": true,
						"Start": 10,
						"Delimiter": 46,
						"Padding": 4,
						"Marker": "MTA=",
						"Num": 10
					},
					"Properties": {
						"id": "20221010220223-qo8svk4",
						"updated": "20221010220223"
					},
					"Children": [
						{
							"ID": "20221010220223-v07d4pe",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221010220223-v07d4pe",
								"updated": "20221010220223"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "如果子类使用 super 显式调用父类的某个构造方法，那么在执行的时候就会寻找与 super 所对应的构造方法而不会再去寻找父类的不带参数的构造方法。与 this 一样，super 也必须要作为构造方法的第一条执行语句，前面不能有其他可执行语句。",
									"Properties": {
										"id": ""
									}
								}
							]
						}
					]
				},
				{
					"ID": "20221010220223-wyk59mw",
					"Type": "NodeListItem",
					"Data": "11",
					"ListData": {
						"Typ": 1,
						"Tight": true,
						"Start": 11,
						"Delimiter": 46,
						"Padding": 4,
						"Marker": "MTE=",
						"Num": 11
					},
					"Properties": {
						"id": "20221010220223-wyk59mw",
						"updated": "20221010220223"
					},
					"Children": [
						{
							"ID": "20221010220223-la0w6rm",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221010220223-la0w6rm",
								"updated": "20221010220223"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "关于继承的 3 点：",
									"Properties": {
										"id": ""
									}
								}
							]
						},
						{
							"ID": "20221010220223-16pzz6g",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221010220223-16pzz6g",
								"updated": "20221010220223"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "a)父类有的，子类也有",
									"Properties": {
										"id": ""
									}
								}
							]
						},
						{
							"ID": "20221010220223-1erjf5b",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221010220223-1erjf5b",
								"updated": "20221010220223"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "b)父类没有的，子类可以增加",
									"Properties": {
										"id": ""
									}
								}
							]
						},
						{
							"ID": "20221010220223-p01htcw",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221010220223-p01htcw",
								"updated": "20221010220223"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "c)父类有的，子类可以改变",
									"Properties": {
										"id": ""
									}
								}
							]
						}
					]
				},
				{
					"ID": "20221010220223-q41a08g",
					"Type": "NodeListItem",
					"Data": "12",
					"ListData": {
						"Typ": 1,
						"Tight": true,
						"Start": 12,
						"Delimiter": 46,
						"Padding": 4,
						"Marker": "MTI=",
						"Num": 12
					},
					"Properties": {
						"id": "20221010220223-q41a08g",
						"updated": "20221010220223"
					},
					"Children": [
						{
							"ID": "20221010220223-8cmv4vs",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221010220223-8cmv4vs",
								"updated": "20221010220223"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "关于继承的注意事项",
									"Properties": {
										"id": ""
									}
								}
							]
						},
						{
							"ID": "20221010220223-zt5170n",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221010220223-zt5170n",
								"updated": "20221010220223"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "a)构造方法不能被继承",
									"Properties": {
										"id": ""
									}
								}
							]
						},
						{
							"ID": "20221010220223-gfq0wjd",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221010220223-gfq0wjd",
								"updated": "20221010220223"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "b)方法和属性可以被继承",
									"Properties": {
										"id": ""
									}
								}
							]
						},
						{
							"ID": "20221010220223-vl5srat",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221010220223-vl5srat",
								"updated": "20221010220223"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "c)子类的构造方法隐式地调用父类的不带参数的构造方法",
									"Properties": {
										"id": ""
									}
								}
							]
						},
						{
							"ID": "20221010220223-vxbgc6g",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221010220223-vxbgc6g",
								"updated": "20221010220223"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "d)当父类没有不带参数的构造方法时，子类需要使用 super 来显式地调用父类的构造方法，super  指的是对父类的引用",
									"Properties": {
										"id": ""
									}
								}
							]
						},
						{
							"ID": "20221010220223-r0yj71v",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221010220223-r0yj71v",
								"updated": "20221010220223"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "e)super 关键字必须是构造方法中的第一行语句。",
									"Properties": {
										"id": ""
									}
								}
							]
						}
					]
				},
				{
					"ID": "20221010220223-if4uvgk",
					"Type": "NodeListItem",
					"Data": "13",
					"ListData": {
						"Typ": 1,
						"Tight": true,
						"Start": 13,
						"Delimiter": 46,
						"Padding": 4,
						"Marker": "MTM=",
						"Num": 13
					},
					"Properties": {
						"id": "20221010220223-if4uvgk",
						"updated": "20221010220223"
					},
					"Children": [
						{
							"ID": "20221010220223-02eiggv",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221010220223-02eiggv",
								"updated": "20221010220223"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "方法重写（Override）：又叫做覆写，子类与父类的方法返回类型一样、方法名称一样，参数一样，这样我们说子类与父类的方法构成了重写关系。",
									"Properties": {
										"id": ""
									}
								}
							]
						}
					]
				},
				{
					"ID": "20221010220223-dgq1gsd",
					"Type": "NodeListItem",
					"Data": "14",
					"ListData": {
						"Typ": 1,
						"Tight": true,
						"Start": 14,
						"Delimiter": 46,
						"Padding": 4,
						"Marker": "MTQ=",
						"Num": 14
					},
					"Properties": {
						"id": "20221010220223-dgq1gsd",
						"updated": "20221010220223"
					},
					"Children": [
						{
							"ID": "20221010220223-ckmfgvs",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221010220223-ckmfgvs",
								"updated": "20221010220223"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "方法重写与方法重载之间的关系：重载发生在同一个类内部的两个或多个方法。重写发生在父类与子类之间。",
									"Properties": {
										"id": ""
									}
								}
							]
						}
					]
				},
				{
					"ID": "20221010220223-9h63uaw",
					"Type": "NodeListItem",
					"Data": "15",
					"ListData": {
						"Typ": 1,
						"Tight": true,
						"Start": 15,
						"Delimiter": 46,
						"Padding": 4,
						"Marker": "MTU=",
						"Num": 15
					},
					"Properties": {
						"id": "20221010220223-9h63uaw",
						"updated": "20221010220223"
					},
					"Children": [
						{
							"ID": "20221010220223-46llc4i",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221010220223-46llc4i",
								"updated": "20221010220223"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "当两个方法形成重写关系时， 可以在子类方法中通过 super.run 形式调用父类的 run 方法，其中 super.run 不必放在第一行语句，因此此时父类对象已经构造完毕，先调用父类的 run 方法还是先调用子类的 run 方法是根据程序的逻辑决定的。",
									"Properties": {
										"id": ""
									}
								}
							]
						}
					]
				},
				{
					"ID": "20221010220223-izo9nus",
					"Type": "NodeListItem",
					"Data": "16",
					"ListData": {
						"Typ": 1,
						"Tight": true,
						"Start": 16,
						"Delimiter": 46,
						"Padding": 4,
						"Marker": "MTY=",
						"Num": 16
					},
					"Properties": {
						"id": "20221010220223-izo9nus",
						"updated": "20221010220223"
					},
					"Children": [
						{
							"ID": "20221010220223-v0judkf",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221010220223-v0judkf",
								"updated": "20221010220223"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "在定义一个类的时候，如果没有显式指定该类的父类，那么该类就会继承于 java.lang.Object 类（JDK 提供的一个类，Object 类是 Java 中所有类的直接或间接父类）。",
									"Properties": {
										"id": ""
									}
								}
							]
						}
					]
				},
				{
					"ID": "20221010220223-aaga5ty",
					"Type": "NodeListItem",
					"Data": "17",
					"ListData": {
						"Typ": 1,
						"Tight": true,
						"Start": 17,
						"Delimiter": 46,
						"Padding": 4,
						"Marker": "MTc=",
						"Num": 17
					},
					"Properties": {
						"id": "20221010220223-aaga5ty",
						"updated": "20221010220223"
					},
					"Children": [
						{
							"ID": "20221010220223-skq3gh2",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221010220223-skq3gh2",
								"updated": "20221010220223"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "多态（Polymorphism）：我们说子类就是父类（玫瑰是花，男人是人），因此多态的意思就是：父类型的引用可以指向子类的对象。",
									"Properties": {
										"id": ""
									}
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20221010220335-an1otiw",
			"Type": "NodeBlockquote",
			"Properties": {
				"id": "20221010220335-an1otiw",
				"style": "color: var(--b3-card-success-color); background-color: var(--b3-card-success-background);",
				"updated": "20221010220359"
			},
			"Children": [
				{
					"Type": "NodeBlockquoteMarker",
					"Data": "\u003e ",
					"Properties": {
						"id": ""
					}
				},
				{
					"ID": "20221010220223-smt8j6m",
					"Type": "NodeParagraph",
					"Properties": {
						"id": "20221010220223-smt8j6m",
						"updated": "20221010220359"
					},
					"Children": [
						{
							"Type": "NodeText",
							"Data": "文章更新历史",
							"Properties": {
								"id": ""
							}
						}
					]
				},
				{
					"ID": "20221010220223-zx840dr",
					"Type": "NodeParagraph",
					"Properties": {
						"id": "20221010220223-zx840dr",
						"updated": "20221010220223"
					},
					"Children": [
						{
							"Type": "NodeText",
							"Data": "2022/05/08 fix:修改备注。",
							"Properties": {
								"id": ""
							}
						}
					]
				}
			]
		}
	]
}