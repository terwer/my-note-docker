{
	"ID": "20221018222506-2c7r8ot",
	"Spec": "1",
	"Type": "NodeDocument",
	"Properties": {
		"custom-cnblogs-post-id": "16805663",
		"custom-desc": "冒泡排序思路_比如_结果_publicclassbubblesort{publicstaticvoidmain(string[]args){int[]a=newint[]{}_for(inti=_ii){systemoutprint(a[i]}systemoutprintln()_bubblesort(a)_systemoutprintln()_systemoutprintln(for(intj=_jj){systemoutprint(a[j]}}publicstaticvoidbubblesort(in",
		"custom-slug": "bubble-sorting-exchange-sorting-and-fast-sorting-hzayq",
		"custom-vuepress-slug": "docs/001.后端开发/001.JavaSE/018.冒泡排序、交换排序与快速排序.md",
		"custom-wordpress-post-id": "4312",
		"custom-yuque-post-id": "97241333_terwer/note",
		"id": "20221018222506-2c7r8ot",
		"tags": "序列,个数,哨兵,比较,交换,冒泡排序,交换排序,快速排序,bubble-sort,quick-sort",
		"title": "018.冒泡排序、交换排序与快速排序",
		"updated": "20221019113005"
	},
	"Children": [
		{
			"ID": "20221018020704-eg5m4uk",
			"Type": "NodeList",
			"ListData": {
				"Typ": 1,
				"Start": 1,
				"Delimiter": 46,
				"Padding": 3,
				"Marker": "MQ==",
				"Num": 1
			},
			"Properties": {
				"id": "20221018020704-eg5m4uk",
				"updated": "20221019113005"
			},
			"Children": [
				{
					"ID": "20221018214245-wa6bcun",
					"Type": "NodeListItem",
					"Data": "1",
					"ListData": {
						"Typ": 1,
						"Start": 1,
						"Delimiter": 46,
						"Padding": 3,
						"Marker": "MQ==",
						"Num": 1
					},
					"Properties": {
						"id": "20221018214245-wa6bcun",
						"updated": "20221019113005"
					},
					"Children": [
						{
							"ID": "20221018214245-yt514fb",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221018214245-yt514fb",
								"updated": "20221018214254"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "冒泡排序",
									"Properties": {
										"id": ""
									}
								}
							]
						},
						{
							"ID": "20221018214303-yzl7ou2",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221018214303-yzl7ou2",
								"updated": "20221018214312"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "思路：",
									"Properties": {
										"id": ""
									}
								}
							]
						},
						{
							"ID": "20221018214312-uaz1ztd",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221018214312-uaz1ztd",
								"updated": "20221018214512"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "比如：3，5，6，2，4，7",
									"Properties": {
										"id": ""
									}
								}
							]
						},
						{
							"ID": "20221018214515-avk8pjh",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221018214515-avk8pjh",
								"updated": "20221018214526"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "结果：2，3，4，5，6，7",
									"Properties": {
										"id": ""
									}
								}
							]
						},
						{
							"ID": "20221018214256-tu70sum",
							"Type": "NodeCodeBlock",
							"IsFencedCodeBlock": true,
							"CodeBlockFenceChar": 96,
							"CodeBlockFenceLen": 3,
							"CodeBlockOpenFence": "YGBg",
							"CodeBlockInfo": "amF2YQ==",
							"CodeBlockCloseFence": "YGBg",
							"Properties": {
								"id": "20221018214256-tu70sum",
								"updated": "20221018221449"
							},
							"Children": [
								{
									"Type": "NodeCodeBlockFenceOpenMarker",
									"Data": "```",
									"CodeBlockFenceLen": 3,
									"Properties": {
										"id": ""
									}
								},
								{
									"Type": "NodeCodeBlockFenceInfoMarker",
									"CodeBlockInfo": "amF2YQ==",
									"Properties": {
										"id": ""
									}
								},
								{
									"Type": "NodeCodeBlockCode",
									"Data": "public class BubbleSort {\n    public static void main(String[] args) {\n        int[] a = new int[]{3, 5, 6, 2, 4, 7};\n\n        for (int i = 0; i \u003c a.length; i++) {\n            System.out.print(a[i] + \" \");\n        }\n        System.out.println();\n\n        bubbleSort(a);\n\n        System.out.println();\n        System.out.println(\"-------------------\");\n\n        for (int j = 0; j \u003c a.length; j++) {\n            System.out.print(a[j] + \" \");\n        }\n    }\n\n    public static void bubbleSort(int[] a) {\n        for (int i = 0; i \u003c a.length - 1; i++) {\n            System.out.println(\"第\" + (i) + \"次比较\");\n\n            for (int j = 0; j \u003c a.length - i - 1; j++) {\n                System.out.println(\"第\" + (j) + \"个数与第\" + (j + 1) + \"个数比较\");\n                if (a[j] \u003e a[j + 1]) {\n                    int temp = a[j];\n                    a[j] = a[j + 1];\n                    a[j + 1] = temp;\n                    System.out.println(\"交换大小\");\n                }\n            }\n\n            for (int k = 0; k \u003c a.length; k++) {\n                System.out.print(a[k] + \" \");\n            }\n            System.out.println();\n            System.out.println(\"====================\");\n        }\n    }\n}\n",
									"Properties": {
										"id": ""
									}
								},
								{
									"Type": "NodeCodeBlockFenceCloseMarker",
									"Data": "```",
									"CodeBlockFenceLen": 3,
									"Properties": {
										"id": ""
									}
								}
							]
						},
						{
							"ID": "20221018215650-hhvsnuc",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221018215650-hhvsnuc",
								"updated": "20221018215653"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "结果",
									"Properties": {
										"id": ""
									}
								}
							]
						},
						{
							"ID": "20221018215654-b0d4f5m",
							"Type": "NodeCodeBlock",
							"IsFencedCodeBlock": true,
							"CodeBlockFenceChar": 96,
							"CodeBlockFenceLen": 3,
							"CodeBlockOpenFence": "YGBg",
							"CodeBlockInfo": "cGxhaW50ZXh0",
							"CodeBlockCloseFence": "YGBg",
							"Properties": {
								"id": "20221018215654-b0d4f5m",
								"updated": "20221018221509"
							},
							"Children": [
								{
									"Type": "NodeCodeBlockFenceOpenMarker",
									"Data": "```",
									"CodeBlockFenceLen": 3,
									"Properties": {
										"id": ""
									}
								},
								{
									"Type": "NodeCodeBlockFenceInfoMarker",
									"CodeBlockInfo": "cGxhaW50ZXh0",
									"Properties": {
										"id": ""
									}
								},
								{
									"Type": "NodeCodeBlockCode",
									"Data": "3 5 6 2 4 7 \n第0次比较\n第0个数与第1个数比较\n第1个数与第2个数比较\n第2个数与第3个数比较\n交换大小\n第3个数与第4个数比较\n交换大小\n第4个数与第5个数比较\n3 5 2 4 6 7 \n====================\n第1次比较\n第0个数与第1个数比较\n第1个数与第2个数比较\n交换大小\n第2个数与第3个数比较\n交换大小\n第3个数与第4个数比较\n3 2 4 5 6 7 \n====================\n第2次比较\n第0个数与第1个数比较\n交换大小\n第1个数与第2个数比较\n第2个数与第3个数比较\n2 3 4 5 6 7 \n====================\n第3次比较\n第0个数与第1个数比较\n第1个数与第2个数比较\n2 3 4 5 6 7 \n====================\n第4次比较\n第0个数与第1个数比较\n2 3 4 5 6 7 \n====================\n\n-------------------\n2 3 4 5 6 7 \n",
									"Properties": {
										"id": ""
									}
								},
								{
									"Type": "NodeCodeBlockFenceCloseMarker",
									"Data": "```",
									"CodeBlockFenceLen": 3,
									"Properties": {
										"id": ""
									}
								}
							]
						},
						{
							"ID": "20221018221902-4ak5qle",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221018221902-4ak5qle",
								"updated": "20221018221908"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "动画",
									"Properties": {
										"id": ""
									}
								}
							]
						},
						{
							"ID": "20221018221909-2x0e4np",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221018221909-2x0e4np",
								"updated": "20221018222640"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "​",
									"Properties": {
										"id": ""
									}
								},
								{
									"Type": "NodeTextMark",
									"Properties": {
										"id": ""
									},
									"TextMarkType": "code",
									"TextMarkTextContent": "https://visualgo.net/zh/sorting?slide=6-5"
								},
								{
									"Type": "NodeText",
									"Data": "​​",
									"Properties": {
										"id": ""
									}
								}
							]
						},
						{
							"ID": "20221018232438-xs96ua8",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221018232438-xs96ua8",
								"updated": "20221018232447"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "简记",
									"Properties": {
										"id": ""
									}
								}
							]
						},
						{
							"ID": "20221018232604-2nyuw27",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221018232604-2nyuw27",
								"updated": "20221019113005"
							},
							"Children": [
								{
									"Type": "NodeTextMark",
									"TextMarkType": "inline-math",
									"TextMarkInlineMathContent": " i =\u003e 0 \\to length - 1 "
								}
							]
						},
						{
							"ID": "20221018232749-dew3wvj",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221018232749-dew3wvj",
								"updated": "20221018232749"
							},
							"Children": [
								{
									"Type": "NodeTextMark",
									"Properties": {
										"id": ""
									},
									"TextMarkType": "inline-math",
									"TextMarkInlineMathContent": " j =\u003e 0 \\to length - i - 1 "
								}
							]
						},
						{
							"ID": "20221018232759-7zj9rie",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221018232759-7zj9rie",
								"updated": "20221018232816"
							},
							"Children": [
								{
									"Type": "NodeTextMark",
									"Properties": {
										"id": ""
									},
									"TextMarkType": "inline-math",
									"TextMarkInlineMathContent": " =\u003e swap({a_j},{a_{j + 1}}) "
								}
							]
						}
					]
				},
				{
					"ID": "20221018233158-w4qmys4",
					"Type": "NodeListItem",
					"Data": "2",
					"ListData": {
						"Typ": 1,
						"Tight": true,
						"Start": 2,
						"Delimiter": 46,
						"Padding": 3,
						"Marker": "Mg==",
						"Num": 2
					},
					"Properties": {
						"id": "20221018233158-w4qmys4",
						"updated": "20221018233158"
					},
					"Children": [
						{
							"ID": "20221018233151-0g69ckg",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221018233151-0g69ckg",
								"updated": "20221018233151"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "交换排序",
									"Properties": {
										"id": ""
									}
								}
							]
						},
						{
							"ID": "20221018233142-s0fn0ny",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221018233142-s0fn0ny",
								"updated": "20221018233144"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "所谓交换，是指根据序列中两个关键字比较的结果来对换这两个关键字在序列中的位置。交换排序本文介绍两种，冒泡排序（bubble sort）和快速排序。",
									"Properties": {
										"id": ""
									}
								}
							]
						}
					]
				},
				{
					"ID": "20221018222646-vsr4bvf",
					"Type": "NodeListItem",
					"Data": "3",
					"ListData": {
						"Typ": 1,
						"Tight": true,
						"Start": 3,
						"Delimiter": 46,
						"Padding": 3,
						"Marker": "Mw==",
						"Num": 3
					},
					"Properties": {
						"id": "20221018222646-vsr4bvf",
						"updated": "20221019000225"
					},
					"Children": [
						{
							"ID": "20221018222646-s9wrful",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221018222646-s9wrful",
								"updated": "20221018222650"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "快速排序",
									"Properties": {
										"id": ""
									}
								}
							]
						},
						{
							"ID": "20221018234606-krnosyu",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221018234606-krnosyu",
								"updated": "20221018234606"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "假设我们现在对“6 1 2 7 9 3 4 5 10 8”这个 10 个数进行排序。首先在这个序列中随便找一个数作为基准数。选取第一个数 6 作为基准数。在这个序列中,将所有比基准数大的数放在 6 的右边，比基准数小的数放在 6 的左边，类似下面这种排列：",
									"Properties": {
										"id": ""
									}
								},
								{
									"Type": "NodeSoftBreak",
									"Data": "\n",
									"Properties": {
										"id": ""
									}
								},
								{
									"Type": "NodeText",
									"Data": "3 1 2 5 4 6 9 7 10 8",
									"Properties": {
										"id": ""
									}
								},
								{
									"Type": "NodeSoftBreak",
									"Data": "\n",
									"Properties": {
										"id": ""
									}
								},
								{
									"Type": "NodeText",
									"Data": "在初始状态下，数字 6 在序列的第 1 位。我们的目标是将 6 挪到序列中间的某个位置，假设这个位置是 k。现在就需要寻找这个 k，并且以第 k 位为分界点，左边的数都小于等于 6，右边的数都大于等于 6。",
									"Properties": {
										"id": ""
									}
								}
							]
						},
						{
							"ID": "20221018234606-i2nvxt4",
							"Type": "NodeHeading",
							"HeadingLevel": 2,
							"Properties": {
								"id": "20221018234606-i2nvxt4",
								"updated": "20221018234606"
							},
							"Children": [
								{
									"Type": "NodeHeadingC8hMarker",
									"Data": "## ",
									"Properties": {
										"id": ""
									}
								},
								{
									"Type": "NodeTextMark",
									"Properties": {
										"id": ""
									},
									"TextMarkType": "strong",
									"TextMarkTextContent": "快速排序"
								}
							]
						},
						{
							"ID": "20221018234606-sdesogx",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221018234606-sdesogx",
								"updated": "20221018234806"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "方法其实很简单：分别从初始序列“6 1 2 7 9 3 4 5 10 8”两端开始“探测”。先从右往左找一个小于 6 的数，再从左往右找一个大于 6 的数，然后交换他们。这里可以用两个变量 i 和 j，分别指向序列最左边和最右边。我们为这两个变量起个好听的名字“哨兵 i”和“哨兵 j”。刚开始的时候让哨兵 i 指向序列的最左边（即 i=1），指向数字 6。让哨兵 j 指向序列的最右边（即=10），指向数字。"
								}
							]
						},
						{
							"ID": "20221018235023-ue3a4ls",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221018235023-ue3a4ls"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "\n​"
								},
								{
									"Type": "NodeImage",
									"Data": "span",
									"Children": [
										{
											"Type": "NodeBang"
										},
										{
											"Type": "NodeOpenBracket"
										},
										{
											"Type": "NodeLinkText"
										},
										{
											"Type": "NodeCloseBracket"
										},
										{
											"Type": "NodeOpenParen"
										},
										{
											"Type": "NodeLinkDest",
											"Data": "https://img1.terwer.space/api/public/20221018234720.png"
										},
										{
											"Type": "NodeCloseParen"
										}
									]
								},
								{
									"Type": "NodeText",
									"Data": "​"
								}
							]
						},
						{
							"ID": "20221018235025-sx6bj83",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221018235025-sx6bj83"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "\n首先哨兵 j 开始出动。因为此处设置的基准数是最左边的数，所以需要让哨兵 j 先出动，这一点非常重要（请自己想一想为什么）。哨兵 j 一步一步地向左挪动（即 j–），直到找到一个小于 6 的数停下来。接下来哨兵 i 再一步一步向右挪动（即 i++），直到找到一个数大于 6 的数停下来。最后哨兵 j 停在了数字 5 面前，哨兵 i 停在了数字 7 面前。"
								}
							]
						},
						{
							"ID": "20221018235223-86zlydv",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221018235223-86zlydv"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "​\n现在交换哨兵 i 和哨兵 j 所指向的元素的值。交换之后的序列如下：6 1 2 5 9 3 4 7 10 8"
								}
							]
						},
						{
							"ID": "20221018235529-qub3zkw",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221018235529-qub3zkw",
								"updated": "20221018235529"
							},
							"Children": [
								{
									"Type": "NodeImage",
									"Data": "span",
									"Children": [
										{
											"Type": "NodeBang"
										},
										{
											"Type": "NodeOpenBracket"
										},
										{
											"Type": "NodeLinkText"
										},
										{
											"Type": "NodeCloseBracket"
										},
										{
											"Type": "NodeOpenParen"
										},
										{
											"Type": "NodeLinkDest",
											"Data": "https://img1.terwer.space/api/public/20221018235119.png"
										},
										{
											"Type": "NodeCloseParen"
										}
									]
								},
								{
									"Type": "NodeText",
									"Data": "​"
								}
							]
						},
						{
							"ID": "20221018235529-ob2abl7",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221018235529-ob2abl7",
								"updated": "20221018235529"
							},
							"Children": [
								{
									"Type": "NodeImage",
									"Data": "span",
									"Children": [
										{
											"Type": "NodeBang"
										},
										{
											"Type": "NodeOpenBracket"
										},
										{
											"Type": "NodeLinkText"
										},
										{
											"Type": "NodeCloseBracket"
										},
										{
											"Type": "NodeOpenParen"
										},
										{
											"Type": "NodeLinkDest",
											"Data": "https://img1.terwer.space/api/public/20221018235204.png"
										},
										{
											"Type": "NodeCloseParen"
										}
									]
								},
								{
									"Type": "NodeText",
									"Data": "​"
								}
							]
						},
						{
							"ID": "20221018235528-p2wxs0y",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221018235528-p2wxs0y"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "​\n到此，第一次交换结束。接下来开始哨兵 j 继续向左挪动（再友情提醒，每次必须是哨兵 j 先出发）。他发现了 4（比基准数 6 要小，满足要求）之后停了下来。哨兵 i 也继续向右挪动的，他发现了 9（比基准数 6 要大，满足要求）之后停了下来。此时再次进行交换，交换之后的序列如下："
								}
							]
						},
						{
							"ID": "20221018234606-hkfb66c",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221018234606-hkfb66c",
								"updated": "20221018234606"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "6 1 2 5 4 3 9 7 10 8"
								}
							]
						},
						{
							"ID": "20221018235510-fgirfmy",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221018235510-fgirfmy",
								"updated": "20221018235558"
							},
							"Children": [
								{
									"Type": "NodeImage",
									"Data": "span",
									"Children": [
										{
											"Type": "NodeBang"
										},
										{
											"Type": "NodeOpenBracket"
										},
										{
											"Type": "NodeLinkText"
										},
										{
											"Type": "NodeCloseBracket"
										},
										{
											"Type": "NodeOpenParen"
										},
										{
											"Type": "NodeLinkDest",
											"Data": "https://img1.terwer.space/api/public/20221018235546.png"
										},
										{
											"Type": "NodeCloseParen"
										}
									]
								}
							]
						},
						{
							"ID": "20221018235624-xal7a7b",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221018235624-xal7a7b",
								"updated": "20221018235632"
							},
							"Children": [
								{
									"Type": "NodeImage",
									"Data": "span",
									"Children": [
										{
											"Type": "NodeBang"
										},
										{
											"Type": "NodeOpenBracket"
										},
										{
											"Type": "NodeLinkText"
										},
										{
											"Type": "NodeCloseBracket"
										},
										{
											"Type": "NodeOpenParen"
										},
										{
											"Type": "NodeLinkDest",
											"Data": "https://img1.terwer.space/api/public/20221018235616.png"
										},
										{
											"Type": "NodeCloseParen"
										}
									]
								},
								{
									"Type": "NodeText",
									"Data": "​"
								}
							]
						},
						{
							"ID": "20221018234606-wsrvkj5",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221018234606-wsrvkj5",
								"updated": "20221018234606"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "第二次交换结束，“探测”继续。哨兵 j 继续向左挪动，他发现了 3（比基准数 6 要小，满足要求）之后又停了下来。哨兵 i 继续向右移动，糟啦！此时哨兵 i 和哨兵 j 相遇了，哨兵 i 和哨兵 j 都走到 3 面前。说明此时“探测”结束。我们将基准数 6 和 3 进行交换。交换之后的序列如下：",
									"Properties": {
										"id": ""
									}
								}
							]
						},
						{
							"ID": "20221018234606-rhrmuhw",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221018234606-rhrmuhw",
								"updated": "20221018234606"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "3 1 2 5 4 6 9 7 10 8"
								}
							]
						},
						{
							"ID": "20221018235752-yw49v5g",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221018235752-yw49v5g",
								"updated": "20221018235753"
							},
							"Children": [
								{
									"Type": "NodeImage",
									"Data": "span",
									"Children": [
										{
											"Type": "NodeBang"
										},
										{
											"Type": "NodeOpenBracket"
										},
										{
											"Type": "NodeLinkText"
										},
										{
											"Type": "NodeCloseBracket"
										},
										{
											"Type": "NodeOpenParen"
										},
										{
											"Type": "NodeLinkDest",
											"Data": "https://img1.terwer.space/api/public/20221018235740.png"
										},
										{
											"Type": "NodeCloseParen"
										}
									]
								},
								{
									"Type": "NodeText",
									"Data": "​"
								}
							]
						},
						{
							"ID": "20221018235752-2uyswpu",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221018235752-2uyswpu",
								"updated": "20221018235813"
							},
							"Children": [
								{
									"Type": "NodeImage",
									"Data": "span",
									"Children": [
										{
											"Type": "NodeBang"
										},
										{
											"Type": "NodeOpenBracket"
										},
										{
											"Type": "NodeLinkText"
										},
										{
											"Type": "NodeCloseBracket"
										},
										{
											"Type": "NodeOpenParen"
										},
										{
											"Type": "NodeLinkDest",
											"Data": "https://img1.terwer.space/api/public/20221018235804.png"
										},
										{
											"Type": "NodeCloseParen"
										}
									]
								},
								{
									"Type": "NodeText",
									"Data": "​"
								}
							]
						},
						{
							"ID": "20221018235813-yka3rfp",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221018235813-yka3rfp",
								"updated": "20221018235836"
							},
							"Children": [
								{
									"Type": "NodeImage",
									"Data": "span",
									"Children": [
										{
											"Type": "NodeBang"
										},
										{
											"Type": "NodeOpenBracket"
										},
										{
											"Type": "NodeLinkText"
										},
										{
											"Type": "NodeCloseBracket"
										},
										{
											"Type": "NodeOpenParen"
										},
										{
											"Type": "NodeLinkDest",
											"Data": "https://img1.terwer.space/api/public/20221018235822.png"
										},
										{
											"Type": "NodeCloseParen"
										}
									]
								},
								{
									"Type": "NodeText",
									"Data": "​\n​\n到此第一轮“探测”真正结束。此时以基准数 6 为分界点，6 左边的数都小于等于 6，6 右边的数都大于等于 6。回顾一下刚才的过程，其实哨兵 j 的使命就是要找小于基准数的数，而哨兵 i 的使命就是要找大于基准数的数，直到 i 和 j 碰头为止。\nOK，解释完毕。现在基准数 6 已经归位，它正好处在序列的第 6 位。此时我们已经将原来的序列，以 6 为分界点拆分成了两个序列，左边的序列是“3 1 2 5 4”，右边的序列是“9 7 10 8”。接下来还需要分别处理这两个序列。因为 6 左边和右边的序列目前都还是很混乱的。不过不要紧，我们已经掌握了方法，接下来只要模拟刚才的方法分别处理 6 左边和右边的序列即可。现在先来处理 6 左边的序列现吧。"
								}
							]
						},
						{
							"ID": "20221018234606-uelt09u",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221018234606-uelt09u",
								"updated": "20221018234606"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "左边的序列是“3 1 2 5 4”。请将这个序列以 3 为基准数进行调整，使得 3 左边的数都小于等于 3，3 右边的数都大于等于 3。好了开始动笔吧",
									"Properties": {
										"id": ""
									}
								}
							]
						},
						{
							"ID": "20221018234606-63ixdyy",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221018234606-63ixdyy",
								"updated": "20221018234606"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "如果你模拟的没有错，调整完毕之后的序列的顺序应该是：",
									"Properties": {
										"id": ""
									}
								}
							]
						},
						{
							"ID": "20221018234606-7g5dt12",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221018234606-7g5dt12",
								"updated": "20221018234606"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "2 1 3 5 4",
									"Properties": {
										"id": ""
									}
								}
							]
						},
						{
							"ID": "20221018234606-1l7cntz",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221018234606-1l7cntz",
								"updated": "20221018234606"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "OK，现在 3 已经归位。接下来需要处理 3 左边的序列“2 1”和右边的序列“5 4”。对序列“2 1”以 2 为基准数进行调整，处理完毕之后的序列为“1 2”，到此 2 已经归位。序列“1”只有一个数，也不需要进行任何处理。至此我们对序列“2 1”已全部处理完毕，得到序列是“1 2”。序列“5 4”的处理也仿照此方法，最后得到的序列如下：",
									"Properties": {
										"id": ""
									}
								}
							]
						},
						{
							"ID": "20221018234606-2idwn2y",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221018234606-2idwn2y",
								"updated": "20221018234606"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "1 2 3 4 5 6 9 7 10 8",
									"Properties": {
										"id": ""
									}
								}
							]
						},
						{
							"ID": "20221018234606-kq60q83",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221018234606-kq60q83",
								"updated": "20221018234606"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "对于序列“9 7 10 8”也模拟刚才的过程，直到不可拆分出新的子序列为止。最终将会得到这样的序列，如下",
									"Properties": {
										"id": ""
									}
								}
							]
						},
						{
							"ID": "20221018234606-kaz6wmi",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221018234606-kaz6wmi",
								"updated": "20221018234606"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "1 2 3 4 5 6 7 8 9 10\n到此，排序完全结束。细心的同学可能已经发现，快速排序的每一轮处理其实就是将这一轮的基准数归位，直到所有的数都归位为止，排序就结束了。下面上个霸气的图来描述下整个算法的处理过程。"
								}
							]
						},
						{
							"ID": "20221019000058-nn74uxq",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221019000058-nn74uxq",
								"updated": "20221019000107"
							},
							"Children": [
								{
									"Type": "NodeImage",
									"Data": "span",
									"Children": [
										{
											"Type": "NodeBang"
										},
										{
											"Type": "NodeOpenBracket"
										},
										{
											"Type": "NodeLinkText"
										},
										{
											"Type": "NodeCloseBracket"
										},
										{
											"Type": "NodeOpenParen"
										},
										{
											"Type": "NodeLinkDest",
											"Data": "https://img1.terwer.space/api/public/20221019000050.png"
										},
										{
											"Type": "NodeCloseParen"
										}
									]
								},
								{
									"Type": "NodeText",
									"Data": "\n"
								}
							]
						},
						{
							"ID": "20221018234606-gk7n1qe",
							"Type": "NodeCodeBlock",
							"IsFencedCodeBlock": true,
							"Properties": {
								"id": "20221018234606-gk7n1qe",
								"updated": "20221019000225"
							},
							"Children": [
								{
									"Type": "NodeCodeBlockFenceOpenMarker",
									"Data": "```"
								},
								{
									"Type": "NodeCodeBlockFenceInfoMarker",
									"CodeBlockInfo": "amF2YQ=="
								},
								{
									"Type": "NodeCodeBlockCode",
									"Data": "\nimport java.util.Arrays;\n\n/**\n * @name: QuickSort\n * @author: terwer\n * @date: 2022-10-19 00:01\n **/\n\npublic class QuickSort {\n    public static void main(String[] args) {\n        int[] nums = {11, 24, 5, 32, 50, 34, 54, 76};\n        System.out.println(\"快速排序前:\" + Arrays.toString(nums));\n        quickSort(nums, 0, nums.length - 1);\n        System.out.println(\"快速排序后:\" + Arrays.toString(nums));\n    }\n\n    public static void quickSort(int[] nums, int start, int end) {\n        if (start \u003e end) return;\n        int i, j, base;\n        i = start;\n        j = end;\n        base = nums[start];\n        while (i \u003c j) {\n            while (i \u003c j \u0026\u0026 nums[j] \u003e= base) j--;\n            while (i \u003c j \u0026\u0026 nums[i] \u003c= base) i++;\n            if (i \u003c j) {\n                swap(nums, i, j);\n            }\n        }\n        swap(nums, start, i);\n        quickSort(nums, start, j - 1);\n        quickSort(nums, j + 1, end);\n    }\n\n    public static void swap(int[] nums, int left, int right) {\n        int temp = nums[left];\n        nums[left] = nums[right];\n        nums[right] = temp;\n    }\n}\n"
								},
								{
									"Type": "NodeCodeBlockFenceCloseMarker",
									"Data": "```"
								}
							]
						}
					]
				}
			]
		}
	]
}